<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Core Metadata -->
    <title>Harmonic Visions: An Immersive Audiovisual Journey</title>
    <meta name="description" content="Experience Harmonic Visions, a transcendent fusion of evolving landscapes, generative soundscapes, and responsive visuals designed for relaxation, meditation, and wonder.">
    <meta name="keywords" content="audiovisual, generative art, ambient music, relaxation, meditation, three.js, web audio, interactive, immersive, transcendence, FatStinkyPanda">
    <meta name="author" content="FatStinkyPanda">
    <meta name="theme-color" content="#0a0a12">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåå</text></svg>">

    <!-- Social Media / Open Graph -->
    <meta property="og:title" content="Harmonic Visions: Transcendent Experience">
    <meta property="og:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="[YOUR_APP_URL_HERE]">
    <meta property="og:image" content="[URL_TO_PREVIEW_IMAGE_HERE]">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Harmonic Visions: Transcendent Experience">
    <meta name="twitter:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta name="twitter:image" content="[URL_TO_PREVIEW_IMAGE_HERE]">

    <!-- Preconnect to CDNs -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.buymeacoffee.com">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- External Stylesheet -->
    <link rel="stylesheet" href="styles.css">

    <style>
      /* Critical styles for immediate rendering */
      :root {
        --primary-color: #2c3e50;
        --secondary-color: #3498db;
        --accent-color: #9b59b6;
        --accent-color-hover: #8e44ad;
        --premium-gold: #e6c656;
        --premium-gradient: linear-gradient(135deg, #8A2387, #E94057, #F27121);
        --premium-gradient-soft: linear-gradient(135deg, rgba(138, 35, 135, 0.8), rgba(233, 64, 87, 0.8), rgba(242, 113, 33, 0.8));
        --cosmic-gradient: linear-gradient(135deg, #3E5151, #DECBA4);
        --glass-effect: rgba(20, 20, 35, 0.8);
        --glass-effect-light: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --background-color: #0a0a12;
        --text-color: #ecf0f1;
        /* Disclaimer Height Variable */
        --disclaimer-height: 60px; /* Default height, adjust as needed */
      }

      body, html {
        margin: 0;
        padding: 0;
        font-family: 'Montserrat', sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        height: 100%;
        overflow: hidden;
      }

      /* Initial loading indicator */
      #initial-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(ellipse at center, #0f1118 0%, #060913 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }

      .spinner {
        width: 60px;
        height: 60px;
        border: 3px solid rgba(52, 152, 219, 0.1);
        border-radius: 50%;
        border-top-color: var(--secondary-color);
        border-left-color: var(--accent-color);
        animation: spin 1.2s linear infinite;
        margin-bottom: 20px;
      }

      .loading-text {
        font-size: 1.2rem;
        color: var(--text-color);
        text-align: center;
        max-width: 80%;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Enhanced loading indicator */
      .loading-indicator {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--background-color);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        gap: 20px;
        transition: opacity 0.5s ease;
      }

      .loading-indicator.fade-out {
        opacity: 0;
        pointer-events: none;
      }

      /* Premium loading elements */
      .premium-loading {
        background: radial-gradient(ellipse at center, #0f1118 0%, #060913 100%);
      }

      .spinner-container {
        position: relative;
        width: 80px;
        height: 80px;
      }

      .spinner-inner {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 40px;
        height: 40px;
        border: 2px solid rgba(155, 89, 182, 0.2);
        border-radius: 50%;
        border-top-color: var(--accent-color);
        animation: spin 1s linear infinite reverse;
      }

      .loading-subtitle {
        font-size: 0.9rem;
        color: rgba(236, 240, 241, 0.7);
        letter-spacing: 2px;
        margin-top: -10px;
      }

      /* Disclaimer Banner */
      .disclaimer-banner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        background: rgba(10, 10, 18, 0.95);
        backdrop-filter: blur(10px);
        color: white;
        z-index: 4000;
        padding: 12px 20px;
        font-size: 0.9rem;
        border-bottom: 1px solid rgba(52, 152, 219, 0.3);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transition: transform 0.5s ease-out, opacity 0.5s ease-out; /* Added transitions */
        transform: translateY(0); /* Start visible */
        opacity: 1;
      }

      .disclaimer-banner.hidden {
          transform: translateY(-100%);
          opacity: 0;
          pointer-events: none;
      }


      .disclaimer-content {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 15px;
      }

      .disclaimer-icon {
        font-size: 1.5rem;
        color: var(--premium-gold);
        flex-shrink: 0;
      }

      .disclaimer-text {
        flex: 1;
        line-height: 1.5;
      }

      .disclaimer-close {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        font-size: 1.2rem;
        padding: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
      }

      .disclaimer-close:hover {
        color: white;
        background: rgba(255, 255, 255, 0.1);
      }

      .disclaimer-highlight {
        color: var(--premium-gold);
        font-weight: 600;
      }

      /* Adjust padding on content below the disclaimer */
      .app-container, .onboarding-overlay {
          /* Use CSS variable for dynamic padding */
          padding-top: var(--disclaimer-height);
          transition: padding-top 0.5s ease-out; /* Smooth transition */
      }

      /* Error state */
      .error-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--background-color);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0 20px;
        text-align: center;
        z-index: 9000;
      }

      .error-title {
        font-size: 2rem;
        margin-bottom: 20px;
        font-family: 'Playfair Display', serif;
      }

      .error-message {
        font-size: 1.1rem;
        margin-bottom: 30px;
        max-width: 600px;
      }

      .error-details {
        padding: 15px;
        background: rgba(255,255,255,0.1);
        border-radius: 8px;
        font-family: monospace;
        text-align: left;
        overflow: auto;
        max-width: 100%;
        margin-top: 20px;
      }

      .reload-button {
        padding: 12px 30px;
        background: linear-gradient(135deg, #3498db, #9b59b6);
        color: white;
        border: none;
        border-radius: 30px;
        font-size: 1rem;
        cursor: pointer;
        margin-top: 20px;
      }

      /* Animations */
      @keyframes pulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
      }

      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      /* Additional responsive fixes */
      @media (max-width: 768px) {
        :root {
            /* Adjust disclaimer height variable for mobile */
            --disclaimer-height: 90px; /* Approximate height on mobile */
        }
        .disclaimer-content {
          flex-direction: column;
          text-align: center;
          padding: 5px 0;
        }

        .disclaimer-banner {
          padding: 15px;
        }

        .disclaimer-close {
          position: absolute;
          top: 10px;
          right: 10px;
        }

      }

      @media (max-width: 480px) {
         :root {
            /* Adjust disclaimer height variable for small mobile */
            --disclaimer-height: 110px; /* Approximate height on small mobile */
         }
        .loading-text {
          font-size: 1rem;
        }

        .disclaimer-banner {
          padding: 15px 10px 10px 10px;
          font-size: 0.8rem;
        }
      }
    </style>

    <!-- Basic noscript message -->
    <noscript>
      <style> #root { display: none; } </style>
      <div style="padding: 20px; text-align: center; color: white; font-family: sans-serif;">
        <h2>JavaScript Required</h2>
        <p>This immersive experience requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
      </div>
    </noscript>
</head>
<body>
    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner" id="disclaimer-banner">
        <div class="disclaimer-content">
            <div class="disclaimer-icon">‚ö†Ô∏è</div>
            <div class="disclaimer-text">
                <span class="disclaimer-highlight">EARLY ACCESS:</span> Harmonic Visions is in active development. By using this application, you acknowledge that it may contain bugs and agree to use it responsibly and at your own risk. Your support through feedback and optional contributions allows us to continue evolving this experience. Thank you for being part of this journey.
            </div>
            <button class="disclaimer-close" id="disclaimer-close" aria-label="Close disclaimer">√ó</button>
        </div>
    </div>

    <!-- Initial Loading Screen -->
    <div id="initial-loader">
        <div class="spinner"></div>
        <div class="loading-text">Creating your transcendent experience...</div>
    </div>

    <!-- React Mount Point -->
    <div id="root"></div>

    <!-- Error handling and resource loading script -->
    <script>
      // Simple error tracking
      window.harmonyErrors = [];
      window.addEventListener('error', function(event) {
        // Ignore Babel compilation errors that are handled elsewhere
        if (event.message.includes("Cannot access '")) return;

        window.harmonyErrors.push({
          message: event.message,
          source: event.filename,
          lineno: event.lineno,
          colno: event.colno,
          error: event.error
        });
        console.error('Caught error:', event);
      });

      // Disclaimer close handler & Auto-hide
      document.addEventListener('DOMContentLoaded', function() {
        const disclaimerClose = document.getElementById('disclaimer-close');
        const disclaimerBanner = document.getElementById('disclaimer-banner');
        const rootElement = document.getElementById('root'); // Or '.app-container' if it exists early

        let hideTimeoutId = null; // Store timeout ID

        function hideDisclaimer() {
            if (disclaimerBanner) {
                disclaimerBanner.classList.add('hidden');
                 // Reset padding on content below when disclaimer hides
                document.documentElement.style.setProperty('--disclaimer-height', '0px');
            }
            if (hideTimeoutId) {
                clearTimeout(hideTimeoutId); // Clear timeout if hidden manually
                hideTimeoutId = null;
            }
        }

        if (disclaimerClose && disclaimerBanner) {
          disclaimerClose.addEventListener('click', hideDisclaimer);

          // Auto-hide after 20 seconds
          hideTimeoutId = setTimeout(hideDisclaimer, 20000); // 20 seconds

          // Set initial padding based on banner height
          // Use requestAnimationFrame to ensure layout is calculated
          requestAnimationFrame(() => {
              if (disclaimerBanner && getComputedStyle(disclaimerBanner).display !== 'none' && !disclaimerBanner.classList.contains('hidden')) {
                  const height = disclaimerBanner.offsetHeight;
                  // Use CSS variable for dynamic padding adjustment
                  document.documentElement.style.setProperty('--disclaimer-height', `${height}px`);
              } else {
                  document.documentElement.style.setProperty('--disclaimer-height', `0px`);
              }
          });
        } else {
            // If banner doesn't exist, ensure padding is 0
            document.documentElement.style.setProperty('--disclaimer-height', `0px`);
        }
      });

      // Safety timeout - if app doesn't initialize properly
      setTimeout(function() {
        const loader = document.getElementById('initial-loader');
        if (loader && loader.style.display !== 'none') {
          // Update the loading text
          const loadingText = loader.querySelector('.loading-text');
          if (loadingText) {
            loadingText.innerHTML = 'Loading is taking longer than expected.<br><br>Please try refreshing the page.';
          }
        }
      }, 15000);  // 15 seconds

      // Final safety - force remove loader after 30 seconds if stuck
      setTimeout(function() {
        const loader = document.getElementById('initial-loader');
        if (loader && loader.style.display !== 'none') {
          loader.style.opacity = '0';
          setTimeout(() => {
            loader.style.display = 'none';
          }, 500);
        }
      }, 30000); // 30 seconds

      // Show error screen function
      window.showErrorScreen = function(message) {
        // Hide the loader
        const loader = document.getElementById('initial-loader');
        if (loader) loader.style.display = 'none';

        // Prevent adding multiple error screens
        if (document.querySelector('.error-container')) return;

        // Create and show error screen
        const errorContainer = document.createElement('div');
        errorContainer.className = 'error-container';
        errorContainer.innerHTML = `
          <h1 class="error-title">Application Error</h1>
          <p class="error-message">${message}</p>
          <button class="reload-button" onclick="window.location.reload()">Refresh Page</button>
          ${window.harmonyErrors.length > 0 ?
          `<div class="error-details">${window.harmonyErrors.map(err =>
            `${err.message} (${err.source}:${err.lineno}:${err.colno})`
          ).join('<br>')}</div>` : ''}
        `;
        document.body.appendChild(errorContainer);
      };
    </script>

    <!-- Stable, sequenced loading of libraries -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Load Custom Application JavaScript Files -->
    <script>
      // Sequential loading of application scripts with completion tracking
      let scriptsLoaded = false;

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          script.async = false; // Try loading sequentially
          script.onload = resolve;
          script.onerror = (err) => {
              console.error(`Failed to load script: ${src}`, err);
              reject(new Error(`Failed to load script: ${src}`));
          };
          document.head.appendChild(script);
        });
      }

      // Helper to hide initial loader
      function hideInitialLoader() {
        const initialLoader = document.getElementById('initial-loader');
        if (initialLoader) {
          initialLoader.style.opacity = '0';
          setTimeout(() => {
            initialLoader.style.display = 'none';
          }, 500);
        }
      }

      // Chain the loading: data.js first, then the rest
      loadScript("data.js")
        .then(() => {
          console.log("data.js loaded.");
          // Now load other dependencies that might rely on data.js
          return Promise.all([
            loadScript("ToastSystem.js"),
            loadScript("AudioEngine.js"),
            loadScript("VisualCanvas.js"),
            loadScript("VideoExporter.js")
          ]);
        })
        .then(() => {
          console.log("All dependencies loaded successfully");
          scriptsLoaded = true;
          // Remove loader only when scripts are loaded and React is ready
          if (window.reactReady) {
            hideInitialLoader();
          }
        })
        .catch(error => {
          console.error("Error loading dependencies:", error);
          window.showErrorScreen("Could not load application dependencies. Please check your connection and refresh the page.");
        });

    </script>

    <!-- Buy Me a Coffee widget - Deferred loading -->
    <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="FatStinkyPanda" data-description="Support me on Buy me a coffee!" data-message="I hope you enjoyed this!! If it's not too much to ask, your support allows me to provide more awesome goodness! :)" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18" defer></script>

    <!-- React Initialization Script (using Babel) -->
    <script type="text/babel">

      // Toast Component with Enhanced Styling
      const Toast = ({ type, message, removing, onClose }) => {
        const icons = {
          success: '‚úì',
          warning: '‚ö†',
          error: '‚úï',
          info: '‚Ñπ'
        };

        return (
          <div className={`toast toast-${type} ${removing ? 'removing' : ''}`}>
            <div className="toast-icon">{icons[type]}</div>
            <div className="toast-message">{message}</div>
          </div>
        );
      };

      // ToastContainer Component
      const ToastContainer = () => {
        const [toasts, setToasts] = React.useState([]);

        React.useEffect(() => {
          if (typeof ToastSystem !== 'undefined') {
            try {
              const unsubscribe = ToastSystem.subscribe(setToasts);
              return unsubscribe;
            } catch (error) {
              console.error("Toast system subscription error:", error);
              return () => {};
            }
          } else {
              console.warn("ToastSystem not available on mount. Retrying subscription shortly...");
              let unsubscribe = null;
              const timeoutId = setTimeout(() => {
                  if (typeof ToastSystem !== 'undefined') {
                     console.log("Retrying ToastSystem subscription...");
                     try {
                        unsubscribe = ToastSystem.subscribe(setToasts);
                     } catch (error) {
                        console.error("Toast system retry subscription error:", error);
                     }
                  } else {
                      console.error("ToastSystem still not available after delay.");
                  }
              }, 500);

              return () => {
                  clearTimeout(timeoutId);
                  if (unsubscribe) unsubscribe();
              };
          }
        }, []);

        return (
          <div className="toast-container">
            {toasts.map(toast => (
              <Toast
                key={toast.id}
                type={toast.type}
                message={toast.message}
                removing={toast.removing}
                onClose={() => {
                    if (typeof ToastSystem !== 'undefined') {
                        ToastSystem.removeToast(toast.id)
                    }
                }}
              />
            ))}
          </div>
        );
      };

      // Enhanced Disclaimer Banner Component for React (with auto-hide)
      const DisclaimerBanner = () => {
        const [visible, setVisible] = React.useState(true);
        const bannerRef = React.useRef(null); // Ref to get height

        const closeDisclaimer = React.useCallback(() => {
          setVisible(false);
          // Reset padding when banner hides
          document.documentElement.style.setProperty('--disclaimer-height', '0px');
        }, []);

        React.useEffect(() => {
            let timeoutId = null;
            if (visible) {
                // Auto-hide after 20 seconds
                timeoutId = setTimeout(closeDisclaimer, 20000);

                // Set padding based on height after render
                requestAnimationFrame(() => {
                    if (bannerRef.current) {
                        const height = bannerRef.current.offsetHeight;
                        document.documentElement.style.setProperty('--disclaimer-height', `${height}px`);
                    }
                });
            }

            // Cleanup function
            return () => {
                clearTimeout(timeoutId);
                // Ensure padding is reset if component unmounts while visible
                if (visible) {
                     document.documentElement.style.setProperty('--disclaimer-height', '0px');
                }
            };
        }, [visible, closeDisclaimer]); // Rerun effect if visibility changes

        // Don't render if not visible
        if (!visible) return null;

        return (
          <div ref={bannerRef} className="disclaimer-banner disclaimer-react">
            <div className="disclaimer-content">
              <div className="disclaimer-icon">‚ö†Ô∏è</div>
              <div className="disclaimer-text">
                <span className="disclaimer-highlight">EARLY ACCESS:</span> Harmonic Visions is in active development. By using this application, you acknowledge that it may contain bugs and agree to use it responsibly and at your own risk. Your support through feedback and optional contributions allows us to continue evolving this experience. Thank you for being part of this journey.
              </div>
              <button className="disclaimer-close" onClick={closeDisclaimer} aria-label="Close disclaimer">√ó</button>
            </div>
          </div>
        );
      };


      // Onboarding Component - Receives moodDescriptions as prop
      const Onboarding = ({ moodDescriptions, onEnter }) => {
        const [timerValue, setTimerValue] = React.useState(30);
        const [timerRunning, setTimerRunning] = React.useState(true);
        const [currentTime, setCurrentTime] = React.useState(30);
        const timerIntervalRef = React.useRef(null);

        React.useEffect(() => {
          if (timerRunning && currentTime > 0) {
            timerIntervalRef.current = setInterval(() => {
              setCurrentTime(prev => prev - 1);
            }, 1000);
          } else if (currentTime === 0) {
            onEnter();
          }
          return () => clearInterval(timerIntervalRef.current);
        }, [timerRunning, currentTime, onEnter]);

        const handleTimerChange = (e) => {
          const value = parseInt(e.target.value, 10);
          setTimerValue(value);
          setCurrentTime(value);
        };
        const toggleTimer = () => setTimerRunning(!timerRunning);
        const resetTimer = () => {
          setCurrentTime(timerValue);
          if (!timerRunning) setTimerRunning(true);
        };
        const formatTime = (seconds) => `${Math.floor(seconds / 60)}:${(seconds % 60).toString().padStart(2, '0')}`;

        // Check if moodDescriptions is valid before mapping
        const descriptionsAvailable = moodDescriptions && typeof moodDescriptions === 'object' && Object.keys(moodDescriptions).length > 0;

        return (
          <div className="onboarding-overlay">
            <div className="onboarding-container">
              <div className="onboarding-card premium-card">
                <div className="premium-badge">Premium Experience</div>
                <h1 className="onboarding-logo">Harmonic Visions</h1>
                <div className="onboarding-subheading">An immersive audiovisual journey</div>
                <p className="onboarding-description">
                  Experience a mesmerizing fusion of evolving landscapes, harmonious sounds, and responsive visuals
                  designed to create a deeply immersive and transcendent experience. Each mood offers a unique
                  journey that resonates with different emotional states.
                </p>
                <div className="creator-attribution">
                  FatStinkyPanda's Transcendence Experience - Unlock your mind and connect with the universe
                </div>
                <div className="onboarding-timer premium-timer">
                  <div className="timer-display">{formatTime(currentTime)}</div>
                  <div className="timer-controls">
                    <button className="timer-button" onClick={toggleTimer}>{timerRunning ? 'Pause' : 'Resume'}</button>
                    <button className="timer-button" onClick={resetTimer}>Reset</button>
                  </div>
                  <div className="timer-progress"><div className="timer-progress-fill" style={{ width: `${(currentTime / timerValue) * 100}%` }}></div></div>
                  <div className="timer-message">Your transcending experience will begin automatically when the timer ends. You can also start your journey anytime by selecting "Begin Journey" below.</div>
                </div>
                <div className="experience-cards">
                  {descriptionsAvailable ? Object.entries(moodDescriptions).map(([mood, description]) => (
                    <div className={`experience-card experience-card-${mood}`} key={mood}>
                      <div className="card-glow"></div>
                      <h3>{mood.charAt(0).toUpperCase() + mood.slice(1)}</h3>
                      <p>{description}</p>
                    </div>
                  )) : <p>Loading mood descriptions...</p>}
                </div>
                <div className="support-message"><p>If you enjoy this experience and find it valuable, your support helps me continue creating more immersive journeys. Thanks for being part of this adventure!</p></div>
                <button className="enter-button premium-button" onClick={onEnter}><span className="button-text">Begin Journey</span><span className="button-icon">‚Üí</span></button>
              </div>
            </div>
          </div>
        );
      };


      // Enhanced LoadingIndicator Component
      const LoadingIndicator = () => {
        return (
          <div className="loading-indicator premium-loading">
            <div className="spinner-container">
              <div className="spinner"></div>
              <div className="spinner-inner"></div>
            </div>
            <div className="loading-text">Creating your experience...</div>
            <div className="loading-subtitle">Preparing to transcend</div>
          </div>
        );
      };

      // Main App Component with Enhanced Features
      function App() {
        // State variables for the application
        const [isPlaying, setIsPlaying] = React.useState(false);
        const [volume, setVolume] = React.useState(0.7);
        const [currentMood, setCurrentMood] = React.useState('calm');
        const [showExportPanel, setShowExportPanel] = React.useState(false);
        const [isExporting, setIsExporting] = React.useState(false);
        const [exportProgress, setExportProgress] = React.useState(0);
        const [exportDuration, setExportDuration] = React.useState(15); // 15 seconds default for testing
        const [exportQuality, setExportQuality] = React.useState('high');
        const [exportFormat, setExportFormat] = React.useState('mp4'); // Default format
        const [showOnboarding, setShowOnboarding] = React.useState(true);
        const [isLoading, setIsLoading] = React.useState(false);
        const [uiVisible, setUiVisible] = React.useState(true); // Track UI visibility
        const [showDisclaimerInApp, setShowDisclaimerInApp] = React.useState(false);
        const [experienceInitialized, setExperienceInitialized] = React.useState(false);

        // References
        const canvasRef = React.useRef(null);
        const audioEngineRef = React.useRef(null);
        const visualCanvasInstanceRef = React.useRef(null); // Ref for the VisualCanvas class instance
        const videoExporterRef = React.useRef(null);
        const exportTimerRef = React.useRef(null);
        const uiVisibilityTimeoutRef = React.useRef(null); // Ref for the UI hide timeout

        // Access global data safely
        const availableMoods = typeof moods !== 'undefined' ? moods : [];
        const availableMoodDescriptions = typeof moodDescriptions !== 'undefined' ? moodDescriptions : {};
        const availableQualityOptions = typeof qualityOptions !== 'undefined' ? qualityOptions : [];
        const availableFormatOptions = typeof formatOptions !== 'undefined' ? formatOptions : [];


        // Effect to handle initial loading state - hide the loader when React app is ready
        React.useEffect(() => {
          console.log("React app mounted");
          window.reactReady = true;

          // Only hide the loader if scripts are loaded as well
          if (window.scriptsLoaded && typeof window.hideInitialLoader === 'function') {
            window.hideInitialLoader();
          }

          return () => {
            window.reactReady = false;
          };
        }, []);

        // Function to get audio data - passed to VisualCanvas
        const getAudioData = React.useCallback(() => {
          if (audioEngineRef.current && audioEngineRef.current.getAudioData && typeof audioEngineRef.current.getAudioData === 'function') {
            try {
              return audioEngineRef.current.getAudioData();
            } catch (error) {
              console.error("Error getting audio data:", error);
              return null;
            }
          }
          return null;
        }, []); // Stable function reference

        // Handle HTML disclaimer closing to show React one later
        React.useEffect(() => {
          // When onboarding is dismissed AND experience is initialized, show React disclaimer
          if (!showOnboarding && experienceInitialized) {
             // Ensure HTML disclaimer is hidden
            const htmlDisclaimer = document.getElementById('disclaimer-banner');
            if (htmlDisclaimer && !htmlDisclaimer.classList.contains('hidden')) {
                 htmlDisclaimer.classList.add('hidden');
                 document.documentElement.style.setProperty('--disclaimer-height', '0px');
            }
            // Show the React disclaimer
            setShowDisclaimerInApp(true);
          }
        }, [showOnboarding, experienceInitialized]);

        // Initialize the AudioEngine and VisualCanvas ONLY after user clicks Begin Journey
        const initializeExperience = React.useCallback(() => {
          if (experienceInitialized) return;

          console.log("Initializing experience...");
          setIsLoading(true);

          // Ensure data is loaded before initializing
          if (typeof moodAudioSettings === 'undefined' || typeof moodSettings === 'undefined') {
              console.error("Data not loaded yet, cannot initialize experience.");
              if (typeof ToastSystem !== 'undefined') {
                  ToastSystem.notify('error', 'Initialization failed: Data not ready. Please refresh.');
              }
              setIsLoading(false);
              return;
          }

          // Initialize AudioEngine
          try {
            audioEngineRef.current = new AudioEngine(false, volume, currentMood);
            console.log("AudioEngine initialized successfully");

            // Once AudioEngine is ready, initialize VisualCanvas
            if (canvasRef.current) {
              visualCanvasInstanceRef.current = new VisualCanvas(
                canvasRef.current,
                currentMood,
                getAudioData // Pass the memoized getter function
              );
              console.log("VisualCanvas initialized successfully");
            }

            // Initialize VideoExporter
            if (canvasRef.current && audioEngineRef.current?.audioContext && audioEngineRef.current?.analyser) {
              videoExporterRef.current = new VideoExporter(
                canvasRef.current,
                audioEngineRef.current.audioContext,
                audioEngineRef.current.analyser
              );
              console.log("VideoExporter initialized successfully");
            }

            setExperienceInitialized(true);

            // Start playing audio after a short delay
            setTimeout(() => {
              setIsLoading(false);

              if (audioEngineRef.current?.audioContext?.state === 'suspended') {
                audioEngineRef.current.audioContext.resume().then(() => {
                  setIsPlaying(true);
                }).catch(e => {
                  console.error("Error resuming audio context:", e);
                  if (typeof ToastSystem !== 'undefined') {
                      ToastSystem.notify('error', 'Could not start audio. Please click/tap again.');
                  }
                });
              } else {
                setIsPlaying(true);
              }
            }, 1500);

          } catch (error) {
            console.error("Error initializing experience:", error);
             if (typeof ToastSystem !== 'undefined') {
                 ToastSystem.notify('error', 'Could not initialize the experience. Please refresh the page.');
             }
            setIsLoading(false);
          }
        }, [volume, currentMood, getAudioData, experienceInitialized]); // Include dependencies

        // === Effects for Updating Class Instances ===

        // Effect to update AudioEngine when relevant state changes
        React.useEffect(() => {
          if (audioEngineRef.current && experienceInitialized) {
            try {
              audioEngineRef.current.setPlaying(isPlaying, currentMood);
              if (audioEngineRef.current.volume !== volume) {
                audioEngineRef.current.setVolume(volume);
              }
            } catch (error) {
              console.error("Error updating AudioEngine:", error);
            }
          }
        }, [isPlaying, currentMood, volume, experienceInitialized]);

        // Effect to update VisualCanvas when relevant state changes
        React.useEffect(() => {
          if (visualCanvasInstanceRef.current && experienceInitialized) {
            try {
              if (visualCanvasInstanceRef.current.mood !== currentMood &&
                  typeof visualCanvasInstanceRef.current.changeMood === 'function') {
                visualCanvasInstanceRef.current.changeMood(currentMood);
              }
              if (typeof visualCanvasInstanceRef.current.animate === 'function') {
                  visualCanvasInstanceRef.current.animate(isPlaying);
              }
              visualCanvasInstanceRef.current.audioData = getAudioData;
            } catch (error) {
              console.error("Error updating VisualCanvas:", error);
            }
          }
        }, [isPlaying, currentMood, getAudioData, experienceInitialized]);


        // Handle play/pause - only available after initialization
        const togglePlayback = React.useCallback(() => {
          if (!experienceInitialized) return;
          try {
            const newState = !isPlaying;
            if (newState && audioEngineRef.current?.audioContext?.state === 'suspended') {
              audioEngineRef.current.audioContext.resume().then(() => {
                setIsPlaying(newState);
              }).catch(e => {
                console.error("Error resuming audio context:", e);
                 if (typeof ToastSystem !== 'undefined') {
                    ToastSystem.notify('error', 'Could not start audio. Please click/tap again.');
                 }
              });
            } else {
              setIsPlaying(newState);
            }
          } catch (error) {
            console.error("Error toggling playback:", error);
             if (typeof ToastSystem !== 'undefined') {
                 ToastSystem.notify('error', 'Error changing playback state.');
             }
          }
        }, [experienceInitialized, isPlaying]);

        // Handle volume change
        const handleVolumeChange = (e) => {
          try {
            const newVolume = parseFloat(e.target.value);
            setVolume(newVolume);
          } catch (error) {
            console.error("Error changing volume:", error);
          }
        };

        // Handle mood change
        const handleMoodChange = React.useCallback((mood) => {
          try {
            if (mood !== currentMood) {
              setCurrentMood(mood);
              if (typeof ToastSystem !== 'undefined') {
                 ToastSystem.notify('info', `Mood changed to ${mood.charAt(0).toUpperCase() + mood.slice(1)}`);
              }
            }
          } catch (error) {
            console.error("Error changing mood:", error);
            if (typeof ToastSystem !== 'undefined') {
                ToastSystem.notify('error', 'Error changing mood.');
            }
          }
        }, [currentMood]);

        // Show/hide export panel
        const toggleExportPanel = React.useCallback(() => {
          setShowExportPanel(prev => !prev);
        }, []);

        // Toggle UI visibility
        const toggleUIVisibility = React.useCallback(() => {
          setUiVisible(prevUiVisible => {
              const nextUiVisible = !prevUiVisible;
              if (!nextUiVisible && uiVisibilityTimeoutRef.current) {
                  clearTimeout(uiVisibilityTimeoutRef.current);
                  uiVisibilityTimeoutRef.current = null;
              }
              return nextUiVisible;
          });
        }, []);

       // Set up keyboard shortcuts - only after experience is initialized
        React.useEffect(() => {
          const handleKeyPress = (e) => {
            if (showOnboarding || !experienceInitialized || showExportPanel || isExporting ||
                e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            if (e.code === 'Space') { e.preventDefault(); togglePlayback(); }
            if (availableMoods.length >= 5) {
                 if (e.code === 'Digit1' || e.code === 'Numpad1') handleMoodChange(availableMoods[0].id);
                 if (e.code === 'Digit2' || e.code === 'Numpad2') handleMoodChange(availableMoods[1].id);
                 if (e.code === 'Digit3' || e.code === 'Numpad3') handleMoodChange(availableMoods[2].id);
                 if (e.code === 'Digit4' || e.code === 'Numpad4') handleMoodChange(availableMoods[3].id);
                 if (e.code === 'Digit5' || e.code === 'Numpad5') handleMoodChange(availableMoods[4].id);
            }
            if (e.code === 'KeyE') { toggleExportPanel(); }
            if (e.code === 'KeyH') { toggleUIVisibility(); }
          };

          if (experienceInitialized) window.addEventListener('keydown', handleKeyPress);
          return () => window.removeEventListener('keydown', handleKeyPress);
        }, [showOnboarding, experienceInitialized, showExportPanel, isExporting, togglePlayback, handleMoodChange, toggleExportPanel, toggleUIVisibility, availableMoods]); // Added availableMoods


        // Handle mouse movement to temporarily show UI - only after experience is initialized
        React.useEffect(() => {
          const handleMouseMove = () => {
            if (uiVisibilityTimeoutRef.current) clearTimeout(uiVisibilityTimeoutRef.current);
            if (!uiVisible) setUiVisible(true);
            if (!showExportPanel) {
              uiVisibilityTimeoutRef.current = setTimeout(() => setUiVisible(false), 3000);
            }
          };

          if (!showOnboarding && experienceInitialized) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('touchstart', handleMouseMove, {passive: true});
            if (uiVisible && !showExportPanel) handleMouseMove();
          }

          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('touchstart', handleMouseMove);
            if (uiVisibilityTimeoutRef.current) clearTimeout(uiVisibilityTimeoutRef.current);
          };
        }, [uiVisible, showOnboarding, showExportPanel, experienceInitialized]);

        // Handle enter from onboarding
        const handleEnterExperience = () => {
          // Hide the original HTML disclaimer immediately if it exists
          const htmlDisclaimer = document.getElementById('disclaimer-banner');
          if (htmlDisclaimer && !htmlDisclaimer.classList.contains('hidden')) {
              htmlDisclaimer.classList.add('hidden');
              document.documentElement.style.setProperty('--disclaimer-height', '0px');
          }
          setShowOnboarding(false);
          setTimeout(initializeExperience, 100);
        };


        // Handle export quality change
        const handleExportQualityChange = (quality) => setExportQuality(quality);
        // Handle export format change
        const handleExportFormatChange = (format) => setExportFormat(format);
        // Handle export duration change
        const handleExportDurationChange = (e) => {
          const duration = parseInt(e.target.value, 10);
          if (!isNaN(duration) && duration >= 5 && duration <= 1800) {
            setExportDuration(duration);
          }
        };

        // Start export process
        const startExport = async () => {
          if (!videoExporterRef.current) {
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Video export is not available. Refresh the page and try again.');
            return;
          }
          if (isExporting) return;

          setIsExporting(true);
          setExportProgress(0);

          try {
            if (!isPlaying || audioEngineRef.current?.audioContext?.state !== 'running') {
                setIsPlaying(true);
                if (audioEngineRef.current?.audioContext?.state === 'suspended') await audioEngineRef.current.audioContext.resume();
                await new Promise(resolve => setTimeout(resolve, 500));
            }

             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', `Recording ${exportDuration}s video... Please wait.`);
            await videoExporterRef.current.startRecording(exportQuality);

            const updateInterval = 100;
            const totalUpdates = exportDuration * (1000 / updateInterval);
            let updateCount = 0;

            if (exportTimerRef.current) clearInterval(exportTimerRef.current);
            exportTimerRef.current = setInterval(() => {
              updateCount++;
              const progress = Math.min((updateCount / totalUpdates) * 100, 99);
              setExportProgress(progress);
              if (updateCount >= totalUpdates) {
                clearInterval(exportTimerRef.current);
                exportTimerRef.current = null;
                finishExport();
              }
            }, updateInterval);
          } catch (error) {
            console.error('Error starting export:', error);
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', `Failed to start recording: ${error.message}. Please try again.`);
            setIsExporting(false);
            if (exportTimerRef.current) clearInterval(exportTimerRef.current);
          }
        };

        // Finish export process
        const finishExport = async () => {
          if (!videoExporterRef.current) {
            if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Video exporter not available for stopping.');
            setIsExporting(false); setExportProgress(0); return;
          }
          try {
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', 'Processing video...');
            const blob = await videoExporterRef.current.stopRecording();
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', 'Finalizing format...');
            const finalBlob = await videoExporterRef.current.convertToFormat(blob, exportFormat, (p) => setExportProgress(99 + p * 0.01));

            let finalExtension = exportFormat;
            if (finalBlob.type.includes('webm')) finalExtension = 'webm'; else if (finalBlob.type.includes('mp4')) finalExtension = 'mp4'; else if (finalBlob.type.includes('gif')) finalExtension = 'gif';

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `harmonic-visions-${currentMood}-${timestamp}.${finalExtension}`;
            const link = videoExporterRef.current.createDownloadLink(finalBlob, filename);

            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

            setExportProgress(100);
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('success', 'Video created! Download started.');

            setTimeout(() => { setIsExporting(false); setExportProgress(0); setShowExportPanel(false); }, 2000);
          } catch (error) {
            console.error('Error completing export:', error);
             if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', `Failed to complete recording: ${error.message}. Try a shorter duration?`);
            setIsExporting(false); setExportProgress(0);
          }
        };

        // Enhanced Export Panel Component
        const EnhancedExportPanel = () => {
          const calculateEstimatedTime = () => {
            const baseTimes = { low: 5, medium: 12, high: 20, ultra: 40 };
            const formatMultiplier = exportFormat === 'gif' ? 2.0 : (exportFormat === 'mp4' ? 1.2 : 1.0);
            const estimatedSeconds = (exportDuration / 60) * (baseTimes[exportQuality] || baseTimes.high) * formatMultiplier;
            const minutes = Math.floor(estimatedSeconds / 60);
            const seconds = Math.floor(estimatedSeconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
          };
          const formatDuration = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

          return (
            <div className="panel active premium-panel">
              <div className="panel-header">
                <h2>Export Video</h2>
                <button className="close-button" onClick={toggleExportPanel} disabled={isExporting} aria-label="Close export panel" > √ó </button>
              </div>
              {isExporting ? (
                <div className="progress-container">
                  <div className="progress-bar"> <div className="progress-fill" style={{ width: `${exportProgress}%` }}></div> <div className="progress-glow" style={{ left: `${exportProgress}%` }}></div> </div>
                  <div className="progress-text"> {exportProgress < 99 ? `Recording: ${exportProgress.toFixed(0)}%` : 'Processing video...'} </div>
                  <div className="progress-details">Please wait while we create your experience</div>
                </div>
              ) : (
                <>
                  <div className="setting-group"> <label htmlFor="duration">Duration (seconds)</label> <input id="duration" type="number" min="5" max="1800" step="5" value={exportDuration} onChange={handleExportDurationChange} /> </div>
                  <div className="setting-group"> <label>Duration (mm:ss)</label> <div>{formatDuration(exportDuration)}</div> </div>
                  <div className="setting-group quality-group"> <label>Quality</label> <div className="quality-options"> {availableQualityOptions.map(opt => (<div key={opt.id} className={`quality-option ${exportQuality === opt.id ? 'selected' : ''}`} onClick={() => handleExportQualityChange(opt.id)} ><h4>{opt.label}</h4><p>{ opt.id === 'low' ? 'Faster export' : opt.id === 'ultra' ? 'Best quality' : `Balanced ${opt.id === 'medium' ? 'performance' : 'quality'}` }</p></div>))} </div> </div>
                  <div className="setting-group format-group"> <label>Format</label> <div className="format-options"> {availableFormatOptions.map(opt => (<div key={opt.id} className={`format-option ${exportFormat === opt.id ? 'selected' : ''}`} onClick={() => handleExportFormatChange(opt.id)} ><div className="format-icon">{ opt.id === 'webm' ? 'üé•' : opt.id === 'mp4' ? 'üìπ' : 'üñºÔ∏è' }</div><div className="format-label">{opt.label}</div></div>))} </div> </div>
                  <div className="estimated-time"> Estimated Processing Time: ~{calculateEstimatedTime()} </div>
                  <button className="action-button premium-button" onClick={startExport}> <span className="button-text">Start Recording</span> <span className="button-icon">‚Üì</span> </button>
                </>
              )}
            </div>
          );
        };

        // === Render ===
        return (
          <div className={`app-container ${!uiVisible ? 'ui-hidden' : ''}`}>
            {/* React Disclaimer is rendered conditionally based on state */}
            {showDisclaimerInApp && <DisclaimerBanner />}

            {showOnboarding ? (
              <Onboarding
                moodDescriptions={availableMoodDescriptions} // Pass data here
                onEnter={handleEnterExperience}
              />
            ) : (
              <main className="main-content">
                <div className="ui-hover-zone top"></div>
                <div className="ui-hover-zone bottom"></div>
                <header className="app-header premium-header">
                  <h1 className="app-title">Harmonic Visions</h1>
                  <div className="creator-badge"> FatStinkyPanda's Transcendence Experience <span className="support-text">Thanks for your support!</span> </div>
                </header>
                <canvas ref={canvasRef} className="visual-canvas" aria-label="Harmonic Visions Visual Experience" />
                <div className="control-panel premium-controls" aria-label="Playback Controls">
                  <div className="control-group"> <button className="play-button" onClick={togglePlayback} aria-label={isPlaying ? "Pause Playback" : "Start Playback"} title={isPlaying ? "Pause (Space)" : "Play (Space)"} > {isPlaying ? '‚ùö‚ùö' : '‚ñ∂'} </button> </div>
                  <div className="control-group"> <label htmlFor="volume">Volume</label> <input id="volume" type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} aria-label="Volume Control" className="premium-slider"/> </div>
                  <div className="control-group"> <label htmlFor="mood">Mood</label> <div className="mood-tooltip">{availableMoodDescriptions[currentMood] || 'Loading...'}</div> <select id="mood" className="control-select premium-select" value={currentMood} onChange={(e) => handleMoodChange(e.target.value)} aria-label="Select Mood (Keys 1-5)" > {availableMoods.map(m => (<option key={m.id} value={m.id}>{m.label}</option>))} </select> </div>
                  <div className="control-group"> <button className="export-button premium-export" onClick={toggleExportPanel} disabled={isExporting} title="Export Video (E)" > <span className="export-button-icon">‚Üì</span> Export Video </button> </div>
                </div>
                <div className="ui-toggle premium-toggle" onClick={toggleUIVisibility} title={uiVisible ? "Hide UI (H)" : "Show UI (H)"} role="button" aria-pressed={!uiVisible} aria-label="Toggle User Interface Visibility"> <span className="ui-toggle-icon">{uiVisible ? '‚ó±' : '‚ó∞'}</span> </div>
                {showExportPanel && <EnhancedExportPanel />}
                <div className="keyboard-shortcuts premium-shortcuts" aria-label="Keyboard Shortcuts Information"> Shortcuts: <span className="keyboard-shortcut">Space</span> Play/Pause <span className="keyboard-shortcut">1-5</span> Mood <span className="keyboard-shortcut">E</span> Export <span className="keyboard-shortcut">H</span> Hide UI </div>
              </main>
            )}
            {isLoading && <LoadingIndicator />}
            <ToastContainer />
          </div>
        );
      }

      // Wrap the React render in a try-catch and provide user feedback for errors
      try {
        console.log("Starting to render React application...");
        window.reactReady = false;
        ReactDOM.render(<App />, document.getElementById('root'), () => {
          console.log("React application mounted successfully");
          window.reactReady = true;
          if (window.scriptsLoaded && typeof window.hideInitialLoader === 'function') {
            window.hideInitialLoader();
          }
        });
      } catch (error) {
        console.error("Failed to render React application:", error);
        const errorMessage = "Application failed to initialize. Please try refreshing the page.";
        if (typeof window.showErrorScreen === 'function') {
          window.showErrorScreen(errorMessage + " Error: " + error.message);
        } else {
          const root = document.getElementById('root');
          if (root) {
            root.innerHTML = `<div style="padding: 30px; text-align: center; color: white;"><h2>Application Error</h2><p>${errorMessage}</p><p style="color: #999; margin-top: 20px;">Error details: ${error.message}</p><button style="margin-top: 20px; padding: 10px 20px;" onclick="window.location.reload()">Refresh Page</button></div>`;
          }
          const initialLoader = document.getElementById('initial-loader');
          if (initialLoader) initialLoader.style.display = 'none';
        }
      }
    </script>
</body>
</html>
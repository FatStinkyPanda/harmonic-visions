<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Core Metadata -->
    <title>Harmonic Visions: An Immersive Audiovisual Journey</title>
    <meta name="description" content="Experience Harmonic Visions, a transcendent fusion of evolving landscapes, generative soundscapes, and responsive visuals designed for relaxation, meditation, and wonder.">
    <meta name="keywords" content="audiovisual, generative art, ambient music, relaxation, meditation, three.js, web audio, interactive, immersive, transcendence, FatStinkyPanda">
    <meta name="author" content="FatStinkyPanda">
    <meta name="theme-color" content="#0a0a12"> <!-- Match background color -->

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌌</text></svg>">

    <!-- Social Media / Open Graph -->
    <meta property="og:title" content="Harmonic Visions: Transcendent Experience">
    <meta property="og:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="[YOUR_APP_URL_HERE]"> <!-- Replace with actual URL when deployed -->
    <meta property="og:image" content="[URL_TO_PREVIEW_IMAGE_HERE]"> <!-- Replace with URL to a preview image -->

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Harmonic Visions: Transcendent Experience">
    <meta name="twitter:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta name="twitter:image" content="[URL_TO_PREVIEW_IMAGE_HERE]"> <!-- Replace with URL to a preview image -->

    <!-- Preconnect to CDNs for potential performance boost -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.buymeacoffee.com">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <!-- Link to External Stylesheet -->
    <link rel="stylesheet" href="styles.css">

    <style>
      /* Critical styles to ensure content is visible before CSS loads */
      .loading-indicator {
        display: flex; 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: #0a0a12; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
        gap: 20px; 
        z-index: 5000;
      }
      
      /* Additional responsive fixes that complement styles.css */
      .timer-message {
        text-align: center;
        margin-top: 10px;
        font-size: 0.9rem;
        color: rgba(236, 240, 241, 0.7);
        background: rgba(0, 0, 0, 0.2);
        padding: 8px 12px;
        border-radius: 8px;
        line-height: 1.4;
      }
      
      @media (max-width: 480px) {
        .onboarding-card {
          padding: 20px 15px;
        }
        
        .onboarding-logo {
          font-size: 2rem;
        }
        
        .onboarding-timer {
          max-width: 100%;
        }
        
        .timer-message {
          font-size: 0.8rem;
        }
        
        .experience-card {
          padding: 12px;
        }
      }
    </style>

    <!-- Basic noscript message -->
    <noscript>
      <style> #root { display: none; } </style>
      <div style="padding: 20px; text-align: center; color: white; font-family: sans-serif;">
        <h2>JavaScript Required</h2>
        <p>This immersive experience requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
      </div>
    </noscript>
</head>
<body>
    <!-- React Mount Point -->
    <div id="root">
        <!-- Initial loading state could be placed here if not handled by React -->
        <div class="loading-indicator">
            <div class="spinner"></div>
            <div class="loading-text">Loading Experience...</div>
        </div>
    </div>

    <!-- Load External JS Libraries -->
    <!-- React & ReactDOM (Load first) -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js" crossorigin></script>

    <!-- Three.js and its dependencies -->
    <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Load Babel standalone for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Load Custom Application JavaScript Files (Standard JS - No JSX Here) -->
    <!-- Order is crucial for dependencies -->
    <script src="data.js"></script>
    <script src="ToastSystem.js"></script>
    <script src="AudioEngine.js"></script>
    <script src="VisualCanvas.js"></script>
    <script src="VideoExporter.js"></script>
    <!-- components.js is NOT loaded here; its content is inside the Babel script -->

    <!-- React Initialization Script (using Babel) -->
    <!-- This script contains all JSX components and the final render call -->
    <script type="text/babel">
      // === Paste the ENTIRE content of components.js below ===

      // Toast Component
      const Toast = ({ type, message, removing, onClose }) => {
          const icons = {
            success: '✓',
            warning: '⚠',
            error: '✕',
            info: 'ℹ'
          };

          return (
            <div className={`toast toast-${type} ${removing ? 'removing' : ''}`}>
              <div className="toast-icon">{icons[type]}</div>
              <div className="toast-message">{message}</div>
            </div>
          );
        };

        // ToastContainer Component
        const ToastContainer = () => {
          const [toasts, setToasts] = React.useState([]);

          React.useEffect(() => {
            const unsubscribe = ToastSystem.subscribe(setToasts);
            return unsubscribe;
          }, []);

          return (
            <div className="toast-container">
              {toasts.map(toast => (
                <Toast
                  key={toast.id}
                  type={toast.type}
                  message={toast.message}
                  removing={toast.removing}
                  onClose={() => ToastSystem.removeToast(toast.id)}
                />
              ))}
            </div>
          );
        };

        // Onboarding Component with timer functionality
        const Onboarding = ({ moodDescriptions, onEnter }) => {
          const [timerValue, setTimerValue] = React.useState(30); // 30 seconds default
          const [timerRunning, setTimerRunning] = React.useState(true);
          const [currentTime, setCurrentTime] = React.useState(30);
          const timerIntervalRef = React.useRef(null);

          // Setup timer
          React.useEffect(() => {
            if (timerRunning && currentTime > 0) {
              timerIntervalRef.current = setInterval(() => {
                setCurrentTime(prev => prev - 1);
              }, 1000);
            } else if (currentTime === 0) {
              // Automatically continue when timer reaches 0
              onEnter();
            }

            return () => {
              if (timerIntervalRef.current) {
                clearInterval(timerIntervalRef.current);
              }
            };
          }, [timerRunning, currentTime, onEnter]);

          // Handle timer value change
          const handleTimerChange = (e) => {
            const value = parseInt(e.target.value, 10);
            setTimerValue(value);
            setCurrentTime(value);
          };

          // Toggle timer
          const toggleTimer = () => {
            setTimerRunning(!timerRunning);
          };

          // Reset timer
          const resetTimer = () => {
            setCurrentTime(timerValue);
            if (!timerRunning) {
              setTimerRunning(true);
            }
          };

          // Format time as MM:SS
          const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
          };

          return (
            <div className="onboarding-overlay">
              <div className="onboarding-container">
                <div className="onboarding-card">
                  <h1 className="onboarding-logo">Harmonic Visions</h1>
                  <div className="onboarding-subheading">An immersive audiovisual journey</div>

                  <p className="onboarding-description">
                    Experience a mesmerizing fusion of evolving landscapes, harmonious sounds, and responsive visuals
                    designed to create a deeply immersive and transcendent experience. Each mood offers a unique
                    journey that resonates with different emotional states.
                  </p>

                  <div className="creator-attribution">
                    FatStinkyPanda's Transcendence Experience - Unlock your mind and connect with the universe
                  </div>

                  <div className="onboarding-timer">
                    <div className="timer-display">{formatTime(currentTime)}</div>
                    <div className="timer-controls">
                      <button className="timer-button" onClick={toggleTimer}>
                        {timerRunning ? 'Pause' : 'Resume'}
                      </button>
                      <button className="timer-button" onClick={resetTimer}>
                        Reset
                      </button>
                    </div>
                    <div className="timer-progress">
                      <div
                        className="timer-progress-fill"
                        style={{ width: `${(currentTime / timerValue) * 100}%` }}
                      ></div>
                    </div>
                    <div className="timer-message">
                      Your transcending experience will begin automatically when the timer ends. 
                      You can also start your journey anytime by selecting "Begin Journey" below.
                    </div>
                  </div>

                  <div className="experience-cards">
                    {Object.entries(moodDescriptions).map(([mood, description]) => (
                      <div className="experience-card" key={mood}>
                        <h3>{mood.charAt(0).toUpperCase() + mood.slice(1)}</h3>
                        <p>{description}</p>
                      </div>
                    ))}
                  </div>

                  <div className="support-message">
                    <p>If you enjoy this experience and find it valuable, your support helps me continue creating more immersive journeys. Thanks for being part of this adventure!</p>
                  </div>

                  <button className="enter-button" onClick={onEnter}>
                    Begin Journey
                  </button>
                </div>
              </div>
            </div>
          );
        };

        // LoadingIndicator Component
        const LoadingIndicator = () => {
          // This component might be briefly visible before React hydrates
          // but will be replaced by the React version once loaded.
          // Alternatively, keep the static HTML version in #root and remove this JS version.
          return (
            <div className="loading-indicator">
              <div className="spinner"></div>
              <div className="loading-text">Creating your experience...</div>
            </div>
          );
        };

        // Main App Component
        function App() {
          // State variables for the application
          const [isPlaying, setIsPlaying] = React.useState(false);
          const [volume, setVolume] = React.useState(0.7);
          const [currentMood, setCurrentMood] = React.useState('calm');
          const [showExportPanel, setShowExportPanel] = React.useState(false);
          const [isExporting, setIsExporting] = React.useState(false);
          const [exportProgress, setExportProgress] = React.useState(0);
          const [exportDuration, setExportDuration] = React.useState(900); // 15 minutes default
          const [exportQuality, setExportQuality] = React.useState('high');
          const [exportFormat, setExportFormat] = React.useState('mp4'); // Default format
          const [showOnboarding, setShowOnboarding] = React.useState(true);
          const [isLoading, setIsLoading] = React.useState(false);
          const [uiVisible, setUiVisible] = React.useState(true); // Track UI visibility

          // References
          const canvasRef = React.useRef(null);
          const audioEngineRef = React.useRef(null);
          const visualCanvasInstanceRef = React.useRef(null); // Ref for the VisualCanvas class instance
          const videoExporterRef = React.useRef(null);
          const exportTimerRef = React.useRef(null);
          const uiVisibilityTimeoutRef = React.useRef(null); // Ref for the UI hide timeout

          // Function to get audio data - passed to VisualCanvas
          const getAudioData = React.useCallback(() => {
            if (audioEngineRef.current && typeof audioEngineRef.current.getAudioData === 'function') {
              return audioEngineRef.current.getAudioData();
            }
            return null;
          }, []); // Stable function reference

          // === Instantiate Non-React Classes ===

          // Instantiate AudioEngine instance via ref (runs once on mount)
          React.useEffect(() => {
              if (!audioEngineRef.current) {
                  try {
                      audioEngineRef.current = new AudioEngine(false, volume, currentMood); // Start paused
                  } catch (error) {
                      console.error("Failed to initialize AudioEngine:", error);
                      ToastSystem.notify('error', 'Could not initialize audio engine.');
                  }
              }
              // Cleanup on unmount
              return () => {
                  if (audioEngineRef.current) {
                      if (typeof audioEngineRef.current.stopAudio === 'function') {
                          audioEngineRef.current.stopAudio();
                      }
                       if (audioEngineRef.current.audioContext && audioEngineRef.current.audioContext.state !== 'closed') {
                           audioEngineRef.current.audioContext.close().catch(e => console.error("Error closing audio context:", e));
                       }
                      audioEngineRef.current = null;
                  }
              };
          }, []); // Empty dependency array: run only once

          // Instantiate VisualCanvas instance via ref (runs after first render when canvasRef is populated)
          React.useEffect(() => {
              if (canvasRef.current && !visualCanvasInstanceRef.current) {
                  try {
                      visualCanvasInstanceRef.current = new VisualCanvas(
                          canvasRef.current,
                          currentMood,
                          getAudioData
                      );
                      // Start animation immediately if needed (e.g., if user skips onboarding fast)
                      if (isPlaying && typeof visualCanvasInstanceRef.current.animate === 'function') {
                          visualCanvasInstanceRef.current.animate(true);
                      }
                  } catch (error) {
                      console.error("Failed to initialize VisualCanvas:", error);
                      ToastSystem.notify('error', 'Could not initialize visuals.');
                  }
              }
              // Cleanup on unmount
              return () => {
                  if (visualCanvasInstanceRef.current && typeof visualCanvasInstanceRef.current.dispose === 'function') {
                      visualCanvasInstanceRef.current.dispose();
                      visualCanvasInstanceRef.current = null;
                  }
              };
          }, [getAudioData, currentMood, isPlaying]); // Re-run if initial mood changes or if isPlaying is true initially

          // Initialize VideoExporter instance
          React.useEffect(() => {
            if (canvasRef.current && audioEngineRef.current?.audioContext && audioEngineRef.current?.analyser && !videoExporterRef.current) {
              try {
                videoExporterRef.current = new VideoExporter(
                  canvasRef.current,
                  audioEngineRef.current.audioContext,
                  audioEngineRef.current.analyser
                );
              } catch (error) {
                console.error("Failed to initialize video exporter:", error);
                ToastSystem.notify('error', 'Could not initialize video export.');
              }
            }
          }, [audioEngineRef.current?.audioContext]); // Re-run if audio context becomes available


          // === Effects for Updating Class Instances ===

          // Effect to update AudioEngine when relevant state changes
          React.useEffect(() => {
              if (audioEngineRef.current) {
                  // Update playing state and mood
                  audioEngineRef.current.setPlaying(isPlaying, currentMood);

                  // Update volume
                  if (audioEngineRef.current.volume !== volume) {
                       audioEngineRef.current.setVolume(volume);
                  }
                  // Update reverb if mood changes
                  if (audioEngineRef.current.mood !== currentMood) {
                      audioEngineRef.current.updateReverb(currentMood);
                      audioEngineRef.current.mood = currentMood; // Update internal mood tracker
                  }
              }
          }, [isPlaying, currentMood, volume]);


          // Effect to update VisualCanvas when relevant state changes
          React.useEffect(() => {
              if (visualCanvasInstanceRef.current) {
                  // Change mood if it differs
                  if (visualCanvasInstanceRef.current.mood !== currentMood && typeof visualCanvasInstanceRef.current.changeMood === 'function') {
                      visualCanvasInstanceRef.current.changeMood(currentMood);
                  }
                  // Control animation loop based on isPlaying state
                  if (typeof visualCanvasInstanceRef.current.animate === 'function') {
                      visualCanvasInstanceRef.current.animate(isPlaying);
                  }
                  // Ensure audioData getter is up-to-date (though useCallback helps)
                  visualCanvasInstanceRef.current.audioData = getAudioData;
              }
          }, [isPlaying, currentMood, getAudioData]);


          // === Event Handlers and Logic ===

          // Set up keyboard shortcuts
          React.useEffect(() => {
            const handleKeyPress = (e) => {
              // Ignore shortcuts if onboarding or export panel is shown, or if exporting
              if (showOnboarding || showExportPanel || isExporting || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

              // Space bar to toggle play/pause
              if (e.code === 'Space') {
                e.preventDefault(); // Prevent scrolling
                togglePlayback();
              }

              // 1-5 to change moods
              if (e.code === 'Digit1' || e.code === 'Numpad1') handleMoodChange('calm');
              if (e.code === 'Digit2' || e.code === 'Numpad2') handleMoodChange('soft');
              if (e.code === 'Digit3' || e.code === 'Numpad3') handleMoodChange('uplifting');
              if (e.code === 'Digit4' || e.code === 'Numpad4') handleMoodChange('warm');
              if (e.code === 'Digit5' || e.code === 'Numpad5') handleMoodChange('cosmic');

              // E to toggle export panel
              if (e.code === 'KeyE') {
                toggleExportPanel();
              }

              // H to toggle UI visibility
              if (e.code === 'KeyH') {
                toggleUIVisibility();
              }
            };

            window.addEventListener('keydown', handleKeyPress);

            return () => {
              window.removeEventListener('keydown', handleKeyPress);
            };
          }, [showOnboarding, showExportPanel, isExporting, currentMood, isPlaying]); // Dependencies ensure shortcuts are active/inactive correctly


          // Handle mouse movement to temporarily show UI
          React.useEffect(() => {
            const handleMouseMove = () => {
              if (uiVisibilityTimeoutRef.current) {
                clearTimeout(uiVisibilityTimeoutRef.current);
              }
              if (!uiVisible) {
                setUiVisible(true);
              }
              if (!showExportPanel) { // Don't auto-hide if export panel is open
                  uiVisibilityTimeoutRef.current = setTimeout(() => {
                      setUiVisible(false);
                  }, 3000);
              }
            };

            if (!showOnboarding) {
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('touchstart', handleMouseMove, {passive: true}); // Add touch support
                if (uiVisible) handleMouseMove(); // Start timer if UI is initially visible
            }

            return () => {
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('touchstart', handleMouseMove);
              if (uiVisibilityTimeoutRef.current) {
                clearTimeout(uiVisibilityTimeoutRef.current);
              }
            };
          }, [uiVisible, showOnboarding, showExportPanel]);

          // Handle enter from onboarding
          const handleEnterExperience = () => {
            setIsLoading(true);
            setTimeout(() => {
              setShowOnboarding(false);
              setIsLoading(false);
               if (audioEngineRef.current?.audioContext?.state === 'suspended') {
                   audioEngineRef.current.audioContext.resume().then(() => {
                       setIsPlaying(true);
                   }).catch(e => {
                       console.error("Error resuming audio context:", e);
                       ToastSystem.notify('error', 'Could not start audio. Please click/tap again.');
                   });
               } else {
                   setIsPlaying(true);
               }
            }, 1500);
          };

          // Handle play/pause
          const togglePlayback = () => {
              const newState = !isPlaying;
              if (newState && audioEngineRef.current?.audioContext?.state === 'suspended') {
                  audioEngineRef.current.audioContext.resume().then(() => {
                      setIsPlaying(newState);
                  }).catch(e => {
                      console.error("Error resuming audio context:", e);
                      ToastSystem.notify('error', 'Could not start audio. Please click/tap again.');
                  });
              } else {
                  setIsPlaying(newState);
              }
          };

          // Handle volume change
          const handleVolumeChange = (e) => {
            const newVolume = parseFloat(e.target.value);
            setVolume(newVolume);
          };

          // Handle mood change
          const handleMoodChange = (mood) => {
            if (mood !== currentMood) {
              setCurrentMood(mood);
              ToastSystem.notify('info', `Mood changed to ${mood.charAt(0).toUpperCase() + mood.slice(1)}`);
            }
          };

          // Show/hide export panel
          const toggleExportPanel = () => {
            setShowExportPanel(!showExportPanel);
          };

          // Toggle UI visibility
          const toggleUIVisibility = () => {
            setUiVisible(!uiVisible);
             // Clear hide timer if manually hiding
             if (!uiVisible && uiVisibilityTimeoutRef.current) {
                clearTimeout(uiVisibilityTimeoutRef.current);
             }
          };

          // Handle export quality change
          const handleExportQualityChange = (quality) => {
            setExportQuality(quality);
          };

          // Handle export format change
          const handleExportFormatChange = (format) => {
            setExportFormat(format);
          };

          // Handle export duration change
          const handleExportDurationChange = (e) => {
              const duration = parseInt(e.target.value, 10);
              if (!isNaN(duration) && duration >= 5 && duration <= 1800) {
                   setExportDuration(duration);
              }
          };

          // Start export process
          const startExport = async () => {
            if (!videoExporterRef.current) {
              ToastSystem.notify('error', 'Video export is not available. Refresh the page and try again.');
              return;
            }
            if (isExporting) return;

            setIsExporting(true);
            setExportProgress(0);

            try {
              if (!isPlaying) {
                setIsPlaying(true);
                await new Promise(resolve => setTimeout(resolve, 300));
              }

              ToastSystem.notify('info', `Recording ${exportDuration}s video... Please wait.`);
              await videoExporterRef.current.startRecording(exportQuality);

              const updateInterval = 100; // ms
              const totalUpdates = exportDuration * (1000 / updateInterval);
              let updateCount = 0;

              exportTimerRef.current = setInterval(() => {
                updateCount++;
                const progress = Math.min((updateCount / totalUpdates) * 100, 99);
                setExportProgress(progress);

                if (updateCount >= totalUpdates) {
                  clearInterval(exportTimerRef.current);
                  exportTimerRef.current = null;
                  finishExport();
                }
              }, updateInterval);

            } catch (error) {
              console.error('Error starting export:', error);
              ToastSystem.notify('error', `Failed to start recording: ${error.message}. Please try again.`);
              setIsExporting(false);
              if (exportTimerRef.current) {
                clearInterval(exportTimerRef.current);
                exportTimerRef.current = null;
              }
            }
          };

          // Finish export process
          const finishExport = async () => {
            if (!videoExporterRef.current) {
                ToastSystem.notify('error', 'Video exporter not available for stopping.');
                setIsExporting(false);
                setExportProgress(0);
                return;
            }
            try {
              ToastSystem.notify('info', 'Processing video...');
              const blob = await videoExporterRef.current.stopRecording();

              ToastSystem.notify('info', 'Finalizing format...');
              const finalBlob = await videoExporterRef.current.convertToFormat(
                blob,
                exportFormat,
                (progress) => { setExportProgress(99 + progress * 0.01); }
              );

              let finalExtension = exportFormat;
              if (finalBlob.type.includes('webm')) finalExtension = 'webm';
              else if (finalBlob.type.includes('mp4')) finalExtension = 'mp4';
              else if (finalBlob.type.includes('gif')) finalExtension = 'gif';

              const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
              const filename = `harmonic-visions-${currentMood}-${timestamp}.${finalExtension}`;
              const link = videoExporterRef.current.createDownloadLink(finalBlob, filename);

              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(link.href);

              setExportProgress(100);
              ToastSystem.notify('success', 'Video created! Download started.');

              setTimeout(() => {
                setIsExporting(false);
                setExportProgress(0);
                setShowExportPanel(false);
              }, 2000);

            } catch (error) {
              console.error('Error completing export:', error);
              ToastSystem.notify('error', `Failed to complete recording: ${error.message}. Try a shorter duration?`);
              setIsExporting(false);
              setExportProgress(0);
            }
          };

          // Enhanced Export Panel Component
          const EnhancedExportPanel = () => {
            // Define quality and format options as these aren't provided in the snippet
            const qualityOptions = [
              { id: 'low', label: 'Low' },
              { id: 'medium', label: 'Medium' },
              { id: 'high', label: 'High' },
              { id: 'ultra', label: 'Ultra' }
            ];
            
            const formatOptions = [
              { id: 'webm', label: 'WebM' },
              { id: 'mp4', label: 'MP4' },
              { id: 'gif', label: 'GIF' }
            ];
            
            const calculateEstimatedTime = () => {
              const baseTimes = { low: 5, medium: 12, high: 20, ultra: 40 }; // seconds per minute
              const formatMultiplier = exportFormat === 'gif' ? 2.0 : (exportFormat === 'mp4' ? 1.2 : 1.0);
              const estimatedSeconds = (exportDuration / 60) * baseTimes[exportQuality] * formatMultiplier;
              const minutes = Math.floor(estimatedSeconds / 60);
              const seconds = Math.floor(estimatedSeconds % 60);
              return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };
            const formatDuration = (totalSeconds) => {
              const minutes = Math.floor(totalSeconds / 60);
              const seconds = totalSeconds % 60;
              return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            };

            return (
              <div className="panel active">
                <div className="panel-header">
                  <h2>Export Video</h2>
                  <button className="close-button" onClick={toggleExportPanel} disabled={isExporting} aria-label="Close export panel" > × </button>
                </div>

                {isExporting ? (
                  <div className="progress-container">
                    <div className="progress-bar"> <div className="progress-fill" style={{ width: `${exportProgress}%` }}></div> </div>
                    <div className="progress-text"> {exportProgress < 99 ? `Recording: ${exportProgress.toFixed(0)}%` : 'Processing video...'} </div>
                  </div>
                ) : (
                  <>
                    <div className="setting-group">
                      <label htmlFor="duration">Duration (seconds)</label>
                      <input id="duration" type="number" min="5" max="1800" step="5" value={exportDuration} onChange={handleExportDurationChange} />
                    </div>
                    <div className="setting-group"> <label>Duration (mm:ss)</label> <div>{formatDuration(exportDuration)}</div> </div>
                    <div className="setting-group quality-group">
                      <label>Quality</label>
                      <div className="quality-options">
                        {qualityOptions.map(opt => (
                          <div key={opt.id} className={`quality-option ${exportQuality === opt.id ? 'selected' : ''}`} onClick={() => handleExportQualityChange(opt.id)} >
                            <h4>{opt.label}</h4>
                            <p>{ opt.id === 'low' ? 'Faster export' : opt.id === 'ultra' ? 'Best quality' : `Balanced ${opt.id === 'medium' ? 'performance' : 'quality'}` }</p>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="setting-group format-group">
                      <label>Format</label>
                      <div className="format-options">
                        {formatOptions.map(opt => (
                          <div key={opt.id} className={`format-option ${exportFormat === opt.id ? 'selected' : ''}`} onClick={() => handleExportFormatChange(opt.id)} >
                            <div className="format-icon">{ opt.id === 'webm' ? '🎥' : opt.id === 'mp4' ? '📹' : '🖼️' }</div>
                            <div className="format-label">{opt.label}</div>
                          </div>
                        ))}
                      </div>
                    </div>
                    <div className="estimated-time"> Estimated Processing Time: ~{calculateEstimatedTime()} </div>
                    <button className="action-button" onClick={startExport} > Start Recording </button>
                  </>
                )}
              </div>
            );
          };

          // === Render ===
          return (
            <div className={`app-container ${!uiVisible ? 'ui-hidden' : ''}`}>
              {showOnboarding ? (
                <Onboarding
                  moodDescriptions={moodDescriptions}
                  onEnter={handleEnterExperience}
                />
              ) : (
                // Use <main> for semantic main content area
                <main className="main-content">
                  {/* UI hover zones for temporary UI visibility */}
                  <div className="ui-hover-zone top"></div>
                  <div className="ui-hover-zone bottom"></div>

                  <header className="app-header">
                    <h1 className="app-title">Harmonic Visions</h1>
                    <div className="creator-badge">
                      FatStinkyPanda's Transcendence Experience
                      <span className="support-text">Thanks for your support!</span>
                    </div>
                  </header>

                  {/* Canvas element for Three.js - VisualCanvas class will attach to this */}
                  <canvas ref={canvasRef} className="visual-canvas" aria-label="Harmonic Visions Visual Experience" />
                  {/* aria-label added for basic accessibility */}

                  {/* AudioEngine and VisualCanvas are managed via refs, not rendered as components */}

                  <div className="control-panel" aria-label="Playback Controls">
                    <div className="control-group">
                      <button className="play-button" onClick={togglePlayback} aria-label={isPlaying ? "Pause Playback" : "Start Playback"} title={isPlaying ? "Pause (Space)" : "Play (Space)"} >
                        {isPlaying ? '❚❚' : '▶'}
                      </button>
                    </div>
                    <div className="control-group">
                      <label htmlFor="volume">Volume</label>
                      <input id="volume" type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} aria-label="Volume Control"/>
                    </div>
                    <div className="control-group">
                      <label htmlFor="mood">Mood</label>
                      <div className="mood-tooltip">{moodDescriptions[currentMood]}</div>
                      <select id="mood" className="control-select" value={currentMood} onChange={(e) => handleMoodChange(e.target.value)} aria-label="Select Mood (Keys 1-5)" >
                        {moods.map(m => (<option key={m.id} value={m.id}>{m.label}</option>))}
                      </select>
                    </div>
                    <div className="control-group">
                      <button className="export-button" onClick={toggleExportPanel} disabled={isExporting} title="Export Video (E)" >
                        <span className="export-button-icon">↓</span>
                        Export Video
                      </button>
                    </div>
                  </div>

                  {/* UI toggle button - Added title attribute */}
                  <div className="ui-toggle" onClick={toggleUIVisibility} title={uiVisible ? "Hide UI (H)" : "Show UI (H)"} role="button" aria-pressed={!uiVisible} aria-label="Toggle User Interface Visibility">
                    <span className="ui-toggle-icon">{uiVisible ? '◱' : '◰'}</span>
                  </div>

                  {showExportPanel && <EnhancedExportPanel />}

                  <div className="keyboard-shortcuts" aria-label="Keyboard Shortcuts Information">
                    Shortcuts: <span className="keyboard-shortcut">Space</span> Play/Pause
                    <span className="keyboard-shortcut">1-5</span> Mood
                    <span className="keyboard-shortcut">E</span> Export
                    <span className="keyboard-shortcut">H</span> Hide UI
                  </div>
                </main> /* End of main content */
              )}

              {isLoading && <LoadingIndicator />}
              <ToastContainer />
            </div>
          );
        }

      // === End of components.js content ===

      // Final Render Call (must be within the text/babel script after App is defined)
      ReactDOM.render(<App />, document.getElementById('root'));
    </script>

    <!-- Buy Me a Coffee widget - Deferred loading -->
    <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="FatStinkyPanda" data-description="Support me on Buy me a coffee!" data-message="I hope you enjoyed this!! If it's not too much to ask, your support allows me to provide more awesome goodness! :)" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18" defer></script>
</body>
</html>
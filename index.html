<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Core Metadata -->
    <title>Harmonic Visions: An Immersive Audiovisual Journey (Modular)</title>
    <meta name="description" content="Experience Harmonic Visions, a transcendent fusion of evolving landscapes, generative soundscapes, and responsive visuals designed for relaxation, meditation, and wonder. Now with a modular visual and audio structure.">
    <meta name="keywords" content="audiovisual, generative art, ambient music, relaxation, meditation, three.js, web audio, interactive, immersive, transcendence, FatStinkyPanda, modular">
    <meta name="author" content="FatStinkyPanda">
    <meta name="theme-color" content="#0a0a12">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌌</text></svg>">

    <!-- Social Media / Open Graph -->
    <meta property="og:title" content="Harmonic Visions: Transcendent Experience">
    <meta property="og:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="[YOUR_APP_URL_HERE]"> <!-- Replace with actual URL -->
    <meta property="og:image" content="[URL_TO_PREVIEW_IMAGE_HERE]"> <!-- Replace with actual Image URL -->

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Harmonic Visions: Transcendent Experience">
    <meta name="twitter:description" content="An immersive journey through evolving landscapes and harmonious sounds.">
    <meta name="twitter:image" content="[URL_TO_PREVIEW_IMAGE_HERE]"> <!-- Replace with actual Image URL -->

    <!-- Preconnect to CDNs -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.buymeacoffee.com">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- External Stylesheet -->
    <link rel="stylesheet" href="styles.css">

    <style>
      /* Critical styles for immediate rendering (Keep your existing styles.css content here or linked) */
      :root {
        --primary-color: #2c3e50;
        --secondary-color: #3498db;
        --accent-color: #9b59b6;
        --accent-color-hover: #8e44ad;
        --premium-gold: #e6c656;
        --premium-gradient: linear-gradient(135deg, #8A2387, #E94057, #F27121);
        --premium-gradient-soft: linear-gradient(135deg, rgba(138, 35, 135, 0.8), rgba(233, 64, 87, 0.8), rgba(242, 113, 33, 0.8));
        --cosmic-gradient: linear-gradient(135deg, #3E5151, #DECBA4);
        --glass-effect: rgba(20, 20, 35, 0.8);
        --glass-effect-light: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --background-color: #0a0a12;
        --text-color: #ecf0f1;
        /* Disclaimer Height Variable */
        --disclaimer-height: 0px; /* Default height, JS will update */
      }

      body, html {
        margin: 0;
        padding: 0;
        font-family: 'Montserrat', sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        height: 100%;
        overflow: hidden;
      }

      /* Initial loading indicator */
      #initial-loader {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(ellipse at center, #0f1118 0%, #060913 100%);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 9999; transition: opacity 0.5s ease-out;
      }
      .spinner {
        width: 60px; height: 60px; border: 3px solid rgba(52, 152, 219, 0.1);
        border-radius: 50%; border-top-color: var(--secondary-color);
        border-left-color: var(--accent-color); animation: spin 1.2s linear infinite; margin-bottom: 20px;
      }
      .loading-text { font-size: 1.2rem; color: var(--text-color); text-align: center; max-width: 80%; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      /* Enhanced loading indicator from styles.css */
       .loading-indicator { /* Copied from styles.css */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--background-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000; gap: 20px;
            transition: opacity 0.5s ease;
        }
       .loading-indicator.fade-out { opacity: 0; pointer-events: none; }
       .premium-loading { background: radial-gradient(ellipse at center, #0f1118 0%, #060913 100%); }
       .spinner-container { position: relative; width: 80px; height: 80px; }
       .premium-loading .spinner { /* Adjusted spinner for premium */
            width: 70px; height: 70px; border: 3px solid rgba(52, 152, 219, 0.1);
            border-radius: 50%; border-top-color: var(--secondary-color);
            border-left-color: var(--accent-color); animation: enhanced-spin 1.2s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
        }
       .spinner-inner {
            position: absolute; top: 15px; left: 15px; width: 40px; height: 40px;
            border: 3px solid rgba(155, 89, 182, 0.1); border-radius: 50%;
            border-right-color: var(--accent-color); border-bottom-color: var(--secondary-color);
            animation: enhanced-spin 0.8s ease-in-out infinite reverse;
        }
       .premium-loading .loading-text {
            font-size: 1.2rem; color: rgba(236, 240, 241, 0.9); text-transform: uppercase;
            letter-spacing: 3px; font-weight: 300; animation: pulse 2s infinite;
        }
       .loading-subtitle {
            font-size: 0.9rem; color: rgba(236, 240, 241, 0.6); font-style: italic;
            margin-top: -10px; font-family: 'Cormorant Garamond', serif; letter-spacing: 1px;
        }
       @keyframes enhanced-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
       @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }


      /* Disclaimer Banner */
       .disclaimer-banner { /* Copied from styles.css */
            position: fixed; top: 0; left: 0; width: 100%;
            background: rgba(10, 10, 18, 0.95); backdrop-filter: blur(10px); color: white;
            z-index: 4000; padding: 12px 20px; font-size: 0.9rem;
            border-bottom: 1px solid rgba(52, 152, 219, 0.3); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.5s ease-out, opacity 0.5s ease-out; transform: translateY(0); opacity: 1;
        }
       .disclaimer-banner.hidden { transform: translateY(-100%); opacity: 0; pointer-events: none; }
       .disclaimer-content { max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between; gap: 15px; }
       .disclaimer-icon { font-size: 1.5rem; color: var(--premium-gold); flex-shrink: 0; }
       .disclaimer-text { flex: 1; line-height: 1.5; }
       .disclaimer-close { background: none; border: none; color: rgba(255, 255, 255, 0.7); cursor: pointer; font-size: 1.2rem; padding: 5px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s; }
       .disclaimer-close:hover { color: white; background: rgba(255, 255, 255, 0.1); }
       .disclaimer-highlight { color: var(--premium-gold); font-weight: 600; }
       .disclaimer-react { /* Specific class for React version if needed */ }


      /* Adjust padding on content below the disclaimer */
      .app-container, .onboarding-overlay {
          padding-top: var(--disclaimer-height);
          transition: padding-top 0.5s ease-out;
      }

      /* Error state */
       .error-container { /* Copied from styles.css */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--background-color); display: flex; flex-direction: column;
            justify-content: center; align-items: center; padding: 0 20px; text-align: center; z-index: 9000;
        }
       .error-title { font-size: 2rem; margin-bottom: 20px; font-family: 'Playfair Display', serif; }
       .error-message { font-size: 1.1rem; margin-bottom: 30px; max-width: 600px; }
       .error-details { padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; font-family: monospace; text-align: left; overflow: auto; max-width: 100%; margin-top: 20px; }
       .reload-button { padding: 12px 30px; background: linear-gradient(135deg, #3498db, #9b59b6); color: white; border: none; border-radius: 30px; font-size: 1rem; cursor: pointer; margin-top: 20px; }


      /* Responsive fixes for disclaimer */
      @media (max-width: 768px) {
        .disclaimer-content { flex-direction: column; text-align: center; padding: 5px 0; }
        .disclaimer-banner { padding: 15px; }
        .disclaimer-close { position: absolute; top: 10px; right: 10px; }
         /* :root { --disclaimer-height: 90px; } /* Let JS handle dynamic height */
      }
      @media (max-width: 480px) {
         .disclaimer-banner { padding: 15px 10px 10px 10px; font-size: 0.8rem; }
         /* :root { --disclaimer-height: 110px; } /* Let JS handle dynamic height */
      }

      /* --- Look Around Hint Styles --- */
      .look-around-hint {
          position: absolute;
          top: 45%; /* Adjust vertical position */
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(15, 15, 30, 0.8);
          color: #e0e0e0;
          padding: 18px 25px;
          border-radius: 15px;
          border: 1px solid rgba(52, 152, 219, 0.3);
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
          backdrop-filter: blur(10px);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.5s ease-in-out;
          animation: hint-fade-in 0.5s ease-out forwards, hint-float 3s ease-in-out infinite 0.5s;
      }

      .look-around-hint.visible {
          opacity: 1;
          pointer-events: auto; /* Allow interaction if needed, though not typical */
      }

      .look-around-hint.fading-out {
          animation: hint-fade-out 0.7s ease-in forwards, hint-float 3s ease-in-out infinite; /* Keep floating while fading */
          pointer-events: none;
      }

      .hint-icon {
          width: 50px;
          height: 50px;
          margin-bottom: 15px;
          position: relative;
      }

      .hint-mouse {
          width: 28px;
          height: 45px;
          border: 2px solid rgba(255, 255, 255, 0.7);
          border-radius: 15px;
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
      }

      .hint-mouse::before { /* Scroll wheel */
          content: '';
          position: absolute;
          top: 8px;
          left: 50%;
          transform: translateX(-50%);
          width: 3px;
          height: 8px;
          background: rgba(255, 255, 255, 0.5);
          border-radius: 2px;
      }

      .hint-drag-arrow {
          position: absolute;
          width: 25px;
          height: 25px;
          border-left: 2px solid var(--secondary-color);
          border-bottom: 2px solid var(--secondary-color);
          transform: rotate(-45deg);
          animation: hint-drag 1.5s ease-in-out infinite;
          opacity: 0.8;
      }

      .hint-text {
          font-size: 1rem;
          font-weight: 500;
          text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      /* Keyframes for Hint */
      @keyframes hint-fade-in {
          from { opacity: 0; transform: translate(-50%, -40%); }
          to { opacity: 1; transform: translate(-50%, -50%); }
      }

      @keyframes hint-fade-out {
          from { opacity: 1; transform: translate(-50%, -50%); }
          to { opacity: 0; transform: translate(-50%, -60%); }
      }

      @keyframes hint-float {
          0%, 100% { transform: translate(-50%, -50%); }
          50% { transform: translate(-50%, -55%); }
      }

      @keyframes hint-drag {
          0% { left: 30%; top: 40%; opacity: 0; }
          20% { opacity: 0.8; }
          80% { left: 60%; top: 40%; opacity: 0.8; }
          100% { opacity: 0; }
      }
      /* --- End Look Around Hint Styles --- */

    </style>

    <!-- Basic noscript message -->
    <noscript>
      <style> #root, #initial-loader, .disclaimer-banner { display: none; } </style>
      <div style="padding: 20px; text-align: center; color: white; font-family: sans-serif;">
        <h2>JavaScript Required</h2>
        <p>This immersive experience requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
      </div>
    </noscript>
</head>
<body>
    <!-- Disclaimer Banner (HTML version, controlled by JS) -->
    <div class="disclaimer-banner" id="disclaimer-banner">
        <div class="disclaimer-content">
            <div class="disclaimer-icon">⚠️</div>
            <div class="disclaimer-text">
                <span class="disclaimer-highlight">EARLY ACCESS:</span> Harmonic Visions is in active development. By using this application, you acknowledge that it may contain bugs and agree to use it responsibly and at your own risk. Your support through feedback and optional contributions allows us to continue evolving this experience. Thank you for being part of this journey.
            </div>
            <button class="disclaimer-close" id="disclaimer-close" aria-label="Close disclaimer">×</button>
        </div>
    </div>

    <!-- Initial Loading Screen -->
    <div id="initial-loader">
        <div class="spinner"></div>
        <div class="loading-text">Creating your transcendent experience...</div>
    </div>

    <!-- React Mount Point -->
    <div id="root"></div>

    <!-- Error handling and resource loading script -->
    <script>
      // Simple error tracking
      window.harmonyErrors = [];
      window.addEventListener('error', function(event) {
        if (event.message.includes("Cannot access '")) return; // Ignore common Babel init noise
        const errorData = {
          message: event.message,
          source: event.filename || 'N/A',
          lineno: event.lineno || 0,
          colno: event.colno || 0,
          error: event.error ? event.error.stack || event.error.toString() : 'N/A'
        };
        window.harmonyErrors.push(errorData);
        console.error('Caught Global Error:', errorData);
      });
      window.addEventListener('unhandledrejection', function(event) {
          const errorData = {
            message: 'Unhandled Promise Rejection',
            reason: event.reason ? event.reason.stack || event.reason.toString() : 'N/A'
          };
          window.harmonyErrors.push(errorData);
          console.error('Caught Unhandled Promise Rejection:', errorData);
      });


      // Disclaimer close handler & Auto-hide
      document.addEventListener('DOMContentLoaded', function() {
        const disclaimerClose = document.getElementById('disclaimer-close');
        const disclaimerBanner = document.getElementById('disclaimer-banner');

        let hideTimeoutId = null; // Store timeout ID

        function setContentPadding(height) {
             // Use CSS variable for dynamic padding adjustment
             document.documentElement.style.setProperty('--disclaimer-height', `${height}px`);
        }

        function hideDisclaimer() {
            if (disclaimerBanner && !disclaimerBanner.classList.contains('hidden')) {
                disclaimerBanner.classList.add('hidden');
                setContentPadding(0); // Reset padding when banner hides
            }
            if (hideTimeoutId) {
                clearTimeout(hideTimeoutId); // Clear timeout if hidden manually
                hideTimeoutId = null;
            }
        }

        if (disclaimerClose && disclaimerBanner) {
          disclaimerClose.addEventListener('click', hideDisclaimer);

          // Auto-hide after 20 seconds
          hideTimeoutId = setTimeout(hideDisclaimer, 20000); // 20 seconds

          // Set initial padding based on banner height after layout calculation
          requestAnimationFrame(() => {
              if (disclaimerBanner && getComputedStyle(disclaimerBanner).display !== 'none' && !disclaimerBanner.classList.contains('hidden')) {
                  const height = disclaimerBanner.offsetHeight;
                  setContentPadding(height);
              } else {
                  setContentPadding(0);
              }
          });
        } else {
            // If banner doesn't exist, ensure padding is 0
            setContentPadding(0);
        }
      });

      // Safety timeout - if app doesn't initialize properly
      const safetyTimeout1 = setTimeout(function() {
        const loader = document.getElementById('initial-loader');
        // Check if loader is still visible AND React hasn't rendered yet
        if (loader && loader.style.display !== 'none' && !window.reactReady) {
          const loadingText = loader.querySelector('.loading-text');
          if (loadingText) {
            loadingText.innerHTML = 'Loading is taking longer than expected.<br>Checking resources...<br><br>If this persists, please try refreshing.';
          }
           console.warn("Safety Timeout 1: Loading seems stuck.");
        }
      }, 15000); // 15 seconds

      // Final safety - force remove loader after 30 seconds if stuck
      const safetyTimeout2 = setTimeout(function() {
        const loader = document.getElementById('initial-loader');
        if (loader && loader.style.display !== 'none' && !window.reactReady) {
          console.error("Safety Timeout 2: Loading took too long. Forcing loader hide. App might be broken.");
          loader.style.opacity = '0';
          setTimeout(() => { loader.style.display = 'none'; }, 500);
          // Optionally show an error message here too
          if (typeof window.showErrorScreen === 'function') {
              window.showErrorScreen('Application failed to load completely. Please refresh.');
          }
        }
      }, 30000); // 30 seconds

      // Function to clear safety timeouts once app is ready
      window.clearSafetyTimeouts = function() {
          clearTimeout(safetyTimeout1);
          clearTimeout(safetyTimeout2);
      };

      // Show error screen function
      window.showErrorScreen = function(message) {
        window.clearSafetyTimeouts(); // Stop safety timeouts if error occurs
        const loader = document.getElementById('initial-loader');
        if (loader) loader.style.display = 'none';
        if (document.querySelector('.error-container')) return; // Prevent multiple error screens

        const errorContainer = document.createElement('div');
        errorContainer.className = 'error-container';
        let errorDetailsHtml = '';
        if (window.harmonyErrors.length > 0) {
            errorDetailsHtml = `<div class="error-details">${window.harmonyErrors.map(err =>
                `Msg: ${err.message || 'Unknown'}<br>Src: ${err.source || err.reason || 'N/A'}${err.lineno ? `:${err.lineno}` : ''}<br>---`
            ).join('<br>')}</div>`;
        }

        errorContainer.innerHTML = `
          <h1 class="error-title">Application Error</h1>
          <p class="error-message">${message}</p>
          <button class="reload-button" onclick="window.location.reload()">Refresh Page</button>
          ${errorDetailsHtml}
        `;
        // Clear existing body content before adding error screen
        document.body.innerHTML = '';
        document.body.appendChild(errorContainer);
        document.body.style.overflow = 'auto'; // Allow scrolling for error details
      };
    </script>

    <!-- Stable, sequenced loading of libraries -->
    <script src="https://unpkg.com/react@17/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
    <!-- Load necessary THREE examples -->
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FXAAShader.js"></script>
    <!-- <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FilmShader.js"></script> --> <!-- Optional -->
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Load Custom Application JavaScript Files -->
    <script>
      // Sequential loading of application scripts with completion tracking
      let dependenciesLoaded = false; // Track dependency loading specifically

      function loadScript(src, id) {
        return new Promise((resolve, reject) => {
          if (document.getElementById(id)) {
            console.log(`Script ${id} already loaded or loading.`);
            resolve(); // Assume it will load or is loaded
            return;
          }
          const script = document.createElement('script');
          script.src = src;
          script.id = id;
          script.async = false; // Enforce sequential execution
          script.onload = () => {
              console.log(`Script loaded successfully: ${src}`);
              resolve();
          };
          script.onerror = (err) => {
              console.error(`Failed to load script: ${src}`, err);
              reject(new Error(`Failed to load script: ${src}`));
          };
          document.head.appendChild(script);
        });
      }

      // Helper to hide initial loader
      function hideInitialLoader() {
        const initialLoader = document.getElementById('initial-loader');
        if (initialLoader && initialLoader.style.display !== 'none') {
          console.log("Hiding initial loader.");
          initialLoader.style.opacity = '0';
          setTimeout(() => {
            initialLoader.style.display = 'none';
            window.clearSafetyTimeouts(); // Clear safety timeouts now
          }, 500);
        }
      }

      // --- CORRECTED SCRIPT LOADING ORDER ---
      console.log("Starting script loading sequence...");
      loadScript("data.js", "data-script")
        .then(() => loadScript("ToastSystem.js", "toast-script"))
        .then(() => loadScript("EmotionAudioList.js", "emotion-audio-list-script"))
        .then(() => loadScript("EmotionVisualList.js", "emotion-visual-list-script"))
        // --- Load ALL Audio Engine Modules FIRST ---
        .then(() => { console.log("Loading Audio Engine Modules..."); return Promise.resolve(); })
        // Pads & Drones
        .then(() => loadScript("ae_pads.js", "ae-pads-script")) // *** Load the main AEPads ***
        .then(() => loadScript("ae_padWarmAnalog.js", "ae-padWarmAnalog-script"))
        .then(() => loadScript("ae_padSoftString.js", "ae-padSoftString-script"))
        .then(() => loadScript("ae_padBrightShimmer.js", "ae-padBrightShimmer-script"))
        .then(() => loadScript("ae_padCosmicDeep.js", "ae-padCosmicDeep-script"))
        .then(() => loadScript("ae_droneMystical.js", "ae-droneMystical-script"))
        .then(() => loadScript("ae_padGlassyFM.js", "ae-padGlassyFM-script"))
        .then(() => loadScript("ae_padFilteredNoise.js", "ae-padFilteredNoise-script"))
        .then(() => loadScript("ae_padResonant.js", "ae-padResonant-script"))
        // Melodic
        .then(() => loadScript("ae_melodySine.js", "ae-melodySine-script"))
        .then(() => loadScript("ae_melodyPluck.js", "ae-melodyPluck-script"))
        .then(() => loadScript("ae_melodyBell.js", "ae-melodyBell-script"))
        .then(() => loadScript("ae_melodyArp.js", "ae-melodyArp-script"))
        .then(() => loadScript("ae_melodyCrystal.js", "ae-melodyCrystal-script"))
        .then(() => loadScript("ae_melodyFluteSynth.js", "ae-melodyFluteSynth-script"))
        .then(() => loadScript("ae_melodySawFiltered.js", "ae-melodySawFiltered-script"))
        // Bass
        .then(() => loadScript("ae_bassSubSine.js", "ae-bassSubSine-script"))
        .then(() => loadScript("ae_bassWarmTriangle.js", "ae-bassWarmTriangle-script"))
        .then(() => loadScript("ae_bassDroneDeep.js", "ae-bassDroneDeep-script"))
        .then(() => loadScript("ae_bassResonantFilter.js", "ae-bassResonantFilter-script"))
        // Percussion
        .then(() => loadScript("ae_percKickSoft.js", "ae-percKickSoft-script"))
        .then(() => loadScript("ae_percKickDeep.js", "ae-percKickDeep-script"))
        .then(() => loadScript("ae_percSnareBrush.js", "ae-percSnareBrush-script"))
        .then(() => loadScript("ae_percHiHatClosed.js", "ae-percHiHatClosed-script"))
        .then(() => loadScript("ae_percHiHatOpen.js", "ae-percHiHatOpen-script"))
        .then(() => loadScript("ae_percShaker.js", "ae-percShaker-script"))
        .then(() => loadScript("ae_percRimshot.js", "ae-percRimshot-script"))
        .then(() => loadScript("ae_percTomLow.js", "ae-percTomLow-script"))
        .then(() => loadScript("ae_percTomMid.js", "ae-percTomMid-script"))
        .then(() => loadScript("ae_percCymbalSwell.js", "ae-percCymbalSwell-script"))
        // Ambient Nature - Water
        .then(() => loadScript("ae_ambientStreamGentle.js", "ae-ambientStreamGentle-script"))
        .then(() => loadScript("ae_ambientWavesCalm.js", "ae-ambientWavesCalm-script"))
        .then(() => loadScript("ae_ambientRainLight.js", "ae-ambientRainLight-script"))
        .then(() => loadScript("ae_ambientRainHeavy.js", "ae-ambientRainHeavy-script"))
        .then(() => loadScript("ae_ambientRainSurface.js", "ae-ambientRainSurface-script"))
        .then(() => loadScript("ae_ambientWaterfallDistant.js", "ae-ambientWaterfallDistant-script"))
        .then(() => loadScript("ae_ambientWaterDrips.js", "ae-ambientWaterDrips-script"))
        // Ambient Nature - Air/Weather
        .then(() => loadScript("ae_ambientWindLight.js", "ae-ambientWindLight-script"))
        .then(() => loadScript("ae_ambientWindHeavy.js", "ae-ambientWindHeavy-script"))
        .then(() => loadScript("ae_ambientThunderDistant.js", "ae-ambientThunderDistant-script"))
        .then(() => loadScript("ae_ambientThunderClose.js", "ae-ambientThunderClose-script"))
        // Ambient Nature - Fire
        .then(() => loadScript("ae_ambientFireCrackle.js", "ae-ambientFireCrackle-script"))
        .then(() => loadScript("ae_ambientFireplace.js", "ae-ambientFireplace-script"))
        // Ambient Nature - Life
        .then(() => loadScript("ae_ambientBirdsong.js", "ae-ambientBirdsong-script"))
        .then(() => loadScript("ae_ambientInsectsNight.js", "ae-ambientInsectsNight-script"))
        // Cosmic & Ethereal
        .then(() => loadScript("ae_cosmicSpaceDrone.js", "ae-cosmicSpaceDrone-script"))
        .then(() => loadScript("ae_cosmicPulsar.js", "ae-cosmicPulsar-script"))
        .then(() => loadScript("ae_cosmicStarlight.js", "ae-cosmicStarlight-script"))
        // Specific Instruments/Effects
        .then(() => loadScript("ae_instrumentPianoChord.js", "ae-instrumentPianoChord-script"))
        .then(() => loadScript("ae_instrumentViolinSwell.js", "ae-instrumentViolinSwell-script"))
        .then(() => loadScript("ae_effectHeartbeat.js", "ae-effectHeartbeat-script"))
        // Example Module (if used)
        .then(() => loadScript("ae_exampleModule.js", "ae-exampleModule-script")) // Example
        // --- Load AudioEngine AFTER its modules ---
        .then(() => { console.log("Loading Audio Engine Core..."); return Promise.resolve(); })
        .then(() => loadScript("AudioEngine.js", "audioengine-script"))
        // --- Load ALL Visual Canvas Modules ---
        .then(() => { console.log("Loading Visual Canvas Modules..."); return Promise.resolve(); })
        .then(() => loadScript("vc_lighting.js", "vclighting-script"))
        .then(() => loadScript("vc_stars.js", "vcstars-script"))
        .then(() => loadScript("vc_landscape.js", "vclandscape-script"))
        .then(() => loadScript("vc_water.js", "vcwater-script"))
        .then(() => loadScript("vc_celestial.js", "vccelestial-script"))
        .then(() => loadScript("vc_plants.js", "vcplants-script"))
        .then(() => loadScript("vc_particles.js", "vcparticles-script"))
        .then(() => loadScript("vc_clouds.js", "vcclouds-script"))
        .then(() => loadScript("vc_dreamEffects.js", "vcdreameffects-script"))
        // --- Load VisualCanvas AFTER its modules ---
        .then(() => { console.log("Loading Visual Canvas Core..."); return Promise.resolve(); })
        .then(() => loadScript("VisualCanvas.js", "visualcanvas-script"))
        // --- Load Connector and Exporter ---
        .then(() => { console.log("Loading Connector and Exporter..."); return Promise.resolve(); })
        .then(() => loadScript("AudioVisualConnector.js", "audiovisualconnector-script"))
        .then(() => loadScript("VideoExporter.js", "videoexporter-script"))
        // --- Dependencies Loaded ---
        .then(() => {
          console.log("All dependencies loaded successfully.");
          dependenciesLoaded = true; // Mark dependencies as loaded
          // Remove loader only when scripts are loaded AND React is ready
          if (window.reactReady) {
            hideInitialLoader();
          }
        })
        .catch(error => {
          console.error("Error loading dependencies:", error);
          if (typeof window.showErrorScreen === 'function') {
            window.showErrorScreen(`Could not load application dependencies (${error.message}). Please check your connection and refresh the page.`);
          } else {
            document.body.innerHTML = `<div style='color:white; padding: 20px;'>Failed to load scripts. Please refresh. Error: ${error.message}</div>`;
          }
        });

    </script>

    <!-- Buy Me a Coffee widget - Deferred loading -->
    <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="FatStinkyPanda" data-description="Support me on Buy me a coffee!" data-message="I hope you enjoyed this!! If it's not too much to ask, your support allows me to provide more awesome goodness! :)" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18" defer></script>

    <!-- React Initialization Script (using Babel) -->
    <script type="text/babel">
      // --- Toast Components ---
      const Toast = ({ type, message, removing, onClose }) => {
        const icons = { success: '✓', warning: '⚠', error: '✕', info: 'ℹ' };
        // Use a default icon if type is unknown (though ToastSystem defaults to 'info')
        const icon = icons[type] || icons['info'];
        return (
          <div className={`toast toast-${type} ${removing ? 'removing' : ''}`}>
            <div className="toast-icon">{icon}</div>
            <div className="toast-message">{message}</div>
            {/* Optional: Add a close button */}
            {/* <button onClick={onClose} className="toast-close-btn">×</button> */}
          </div>
        );
      };

      const ToastContainer = () => {
        const [toasts, setToasts] = React.useState([]);
        React.useEffect(() => {
          let unsubscribe = null;
          if (typeof ToastSystem !== 'undefined' && ToastSystem.subscribe) {
            unsubscribe = ToastSystem.subscribe(setToasts);
          } else {
            console.warn("ToastSystem not ready for subscription on mount.");
            // Retry mechanism could be added here if needed
          }
          return () => {
              if (unsubscribe) {
                  unsubscribe();
              }
          };
        }, []); // Empty dependency array ensures this runs only once on mount

        const handleClose = (id) => {
             if (typeof ToastSystem !== 'undefined' && ToastSystem.removeToast) {
                  ToastSystem.removeToast(id);
             } else {
                  console.warn("ToastSystem not available for removeToast.");
             }
        };

        return (
          <div className="toast-container">
            {toasts.map(toast => (
              <Toast key={toast.id} {...toast} onClose={() => handleClose(toast.id)} />
            ))}
          </div>
        );
      };

      // --- Disclaimer Banner (React Version) ---
      const DisclaimerBanner = () => {
        const [visible, setVisible] = React.useState(true);
        const bannerRef = React.useRef(null);

        const closeDisclaimer = React.useCallback(() => {
          setVisible(false);
          // Ensure padding is reset when React hides the banner
          document.documentElement.style.setProperty('--disclaimer-height', '0px');
        }, []);

        React.useEffect(() => {
          let timeoutId = null;
          if (visible) {
            timeoutId = setTimeout(closeDisclaimer, 20000); // Auto-hide
            // Set padding after render ensures correct height calculation
            requestAnimationFrame(() => {
              if (bannerRef.current) {
                const height = bannerRef.current.offsetHeight;
                document.documentElement.style.setProperty('--disclaimer-height', `${height}px`);
              }
            });
          } else {
               // Explicitly set padding to 0 if banner is not visible initially or gets hidden
               document.documentElement.style.setProperty('--disclaimer-height', '0px');
          }
          return () => clearTimeout(timeoutId);
        }, [visible, closeDisclaimer]);

        if (!visible) return null;

        return (
          <div ref={bannerRef} className="disclaimer-banner disclaimer-react">
            <div className="disclaimer-content">
              <div className="disclaimer-icon">⚠️</div>
              <div className="disclaimer-text">
                <span className="disclaimer-highlight">EARLY ACCESS:</span> Harmonic Visions is in active development. By using this application, you acknowledge that it may contain bugs and agree to use it responsibly and at your own risk. Your support through feedback and optional contributions allows us to continue evolving this experience. Thank you for being part of this journey.
              </div>
              <button className="disclaimer-close" onClick={closeDisclaimer} aria-label="Close disclaimer">×</button>
            </div>
          </div>
        );
      };

      // --- Onboarding Component ---
       const Onboarding = ({ moodDescriptions, onEnter }) => {
            const [timerValue, setTimerValue] = React.useState(30); // Default timer duration
            const [timerRunning, setTimerRunning] = React.useState(true);
            const [currentTime, setCurrentTime] = React.useState(timerValue); // Initialize with timerValue
            const timerIntervalRef = React.useRef(null);

            React.useEffect(() => {
                if (timerRunning && currentTime > 0) {
                    timerIntervalRef.current = setInterval(() => {
                        setCurrentTime(prev => Math.max(0, prev - 1)); // Prevent going below 0
                    }, 1000);
                } else if (currentTime === 0 && timerRunning) { // Only trigger onEnter if timer was running and reached 0
                    clearInterval(timerIntervalRef.current); // Stop interval first
                    onEnter();
                }
                // Cleanup interval on unmount or when timer stops/resets
                return () => clearInterval(timerIntervalRef.current);
            }, [timerRunning, currentTime, onEnter]); // Dependencies

            const handleTimerChange = (e) => {
                const value = parseInt(e.target.value, 10);
                if (!isNaN(value) && value >= 5 && value <= 300) { // Example range 5s to 5min
                    setTimerValue(value);
                    setCurrentTime(value); // Reset current time when value changes
                    if (!timerRunning) setTimerRunning(true); // Optionally restart timer on change
                }
            };
            const toggleTimer = () => setTimerRunning(prev => !prev);
            const resetTimer = () => {
                clearInterval(timerIntervalRef.current); // Clear existing interval
                setCurrentTime(timerValue);
                if (!timerRunning) setTimerRunning(true); // Ensure timer starts if paused
            };
            const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
            // Use safe access to global data loaded earlier
            const descriptions = (typeof moodDescriptions !== 'undefined' && moodDescriptions) ? moodDescriptions : {};
            const descriptionsAvailable = Object.keys(descriptions).length > 0;

            return (
                <div className="onboarding-overlay">
                    <div className="onboarding-container">
                        <div className="onboarding-card premium-card">
                            <div className="premium-badge">Premium Experience</div>
                            <h1 className="onboarding-logo">Harmonic Visions</h1>
                            <div className="onboarding-subheading">An immersive audiovisual journey</div>
                            <p className="onboarding-description">
                                Experience a mesmerizing fusion of evolving landscapes, harmonious sounds, and responsive visuals
                                designed to create a deeply immersive and transcendent experience. Each mood offers a unique
                                journey that resonates with different emotional states.
                            </p>
                            <div className="creator-attribution">
                                FatStinkyPanda's Transcendence Experience - Unlock your mind and connect with the universe
                            </div>
                            <div className="onboarding-timer premium-timer">
                                <div className="timer-display">{formatTime(currentTime)}</div>
                                <div className="timer-controls">
                                    <button className="timer-button" onClick={toggleTimer}>{timerRunning ? 'Pause' : 'Resume'}</button>
                                    <button className="timer-button" onClick={resetTimer}>Reset</button>
                                    {/* Optional: Input to change timer duration */}
                                    {/* <input type="number" min="5" max="300" value={timerValue} onChange={handleTimerChange} style={{width: '60px', marginLeft: '10px'}}/> */}
                                </div>
                                <div className="timer-progress"><div className="timer-progress-fill" style={{ width: `${(currentTime / timerValue) * 100}%` }}></div></div>
                                <div className="timer-message">Your transcending experience will begin automatically...</div>
                            </div>
                            <div className="experience-cards">
                                {descriptionsAvailable ? Object.entries(descriptions).map(([mood, description]) => (
                                    <div className={`experience-card experience-card-${mood}`} key={mood}>
                                        <div className="card-glow"></div>
                                        <h3>{mood.charAt(0).toUpperCase() + mood.slice(1)}</h3>
                                        <p>{description}</p>
                                    </div>
                                )) : <p>Loading mood descriptions...</p>}
                            </div>
                            <div className="support-message"><p>If you enjoy this experience and find it valuable, your support helps me continue creating more immersive journeys. Thanks for being part of this adventure!</p></div>
                            <button className="enter-button premium-button" onClick={onEnter}><span className="button-text">Begin Journey</span><span className="button-icon">→</span></button>
                        </div>
                    </div>
                </div>
            );
        };


      // --- Loading Indicator Component ---
      const LoadingIndicator = () => {
        return (
          <div className="loading-indicator premium-loading">
            <div className="spinner-container">
              <div className="spinner"></div>
              <div className="spinner-inner"></div>
            </div>
            <div className="loading-text">Creating your experience...</div>
            <div className="loading-subtitle">Preparing to transcend</div>
          </div>
        );
      };

      // --- Look Around Hint Component ---
      const LookAroundHint = ({ isVisible, onComplete }) => {
          const [isFadingOut, setIsFadingOut] = React.useState(false);
          const timeoutRef = React.useRef(null);

          React.useEffect(() => {
              if (isVisible) {
                  // Clear any existing timeouts
                  if (timeoutRef.current) clearTimeout(timeoutRef.current);

                  // Start fade-out after a delay (e.g., 3 seconds)
                  timeoutRef.current = setTimeout(() => {
                      setIsFadingOut(true);
                      // Call onComplete after the fade-out animation finishes
                      setTimeout(() => {
                          onComplete(); // Notify parent that the hint cycle is done
                      }, 700); // Matches fade-out duration in CSS
                  }, 3000); // Display duration before fading
              }

              // Cleanup timeout on unmount or if isVisible becomes false early
              return () => clearTimeout(timeoutRef.current);
          }, [isVisible, onComplete]);

          // Don't render anything if not visible and not fading out
          if (!isVisible && !isFadingOut) {
              return null;
          }

          return (
              <div className={`look-around-hint ${isVisible ? 'visible' : ''} ${isFadingOut ? 'fading-out' : ''}`}>
                  <div className="hint-icon">
                      <div className="hint-mouse"></div>
                      <div className="hint-drag-arrow"></div>
                  </div>
                  <div className="hint-text">Click & Drag to Look Around</div>
              </div>
          );
      };

      // --- Main App Component (Refactored Initialization) ---
      function App() {
        const [isPlaying, setIsPlaying] = React.useState(false);
        const [volume, setVolume] = React.useState(0.7);
        const [currentMood, setCurrentMood] = React.useState('calm');
        const [showExportPanel, setShowExportPanel] = React.useState(false);
        const [isExporting, setIsExporting] = React.useState(false);
        const [exportProgress, setExportProgress] = React.useState(0);
        const [exportDuration, setExportDuration] = React.useState(15); // Default 15s
        const [exportQuality, setExportQuality] = React.useState('high');
        const [exportFormat, setExportFormat] = React.useState('webm'); // Default webm
        const [showOnboarding, setShowOnboarding] = React.useState(true);
        const [isLoading, setIsLoading] = React.useState(false);
        const [uiVisible, setUiVisible] = React.useState(true);
        const [showDisclaimerInApp, setShowDisclaimerInApp] = React.useState(false);
        const [experienceInitialized, setExperienceInitialized] = React.useState(false);
        // State for the look around hint
        const [showLookAroundHint, setShowLookAroundHint] = React.useState(false);
        const hintShownRef = React.useRef(false); // Track if hint has been shown this session

        // Refs
        const canvasRef = React.useRef(null);
        const audioEngineRef = React.useRef(null);
        const visualCanvasRef = React.useRef(null);
        const audioConnectorRef = React.useRef(null);
        const videoExporterRef = React.useRef(null);
        const exportTimerRef = React.useRef(null);
        const uiVisibilityTimeoutRef = React.useRef(null);

        // Access global data safely
        const availableMoods = (typeof moods !== 'undefined' && Array.isArray(moods)) ? moods : [{ id: 'calm', label: 'Calm' }];
        const availableMoodDescriptions = (typeof moodDescriptions !== 'undefined' && moodDescriptions) ? moodDescriptions : { calm: "Default calm description." };
        const availableQualityOptions = (typeof qualityOptions !== 'undefined' && Array.isArray(qualityOptions)) ? qualityOptions : [{ id: 'high', label: 'High' }];
        const availableFormatOptions = (typeof formatOptions !== 'undefined' && Array.isArray(formatOptions)) ? formatOptions : [{ id: 'webm', label: 'WebM' }];

        // Effect for initial loading state
        React.useEffect(() => {
          console.log("React app mounted");
          window.reactReady = true;
          if (window.dependenciesLoaded && typeof window.hideInitialLoader === 'function') {
            hideInitialLoader();
          }
          return () => {
              console.log("React App unmounting - disposing resources...");
              window.reactReady = false;
              audioEngineRef.current?.dispose();
              visualCanvasRef.current?.dispose();
              audioEngineRef.current = null;
              visualCanvasRef.current = null;
              audioConnectorRef.current = null;
              videoExporterRef.current = null;
          };
        }, []);

        // Handle HTML disclaimer sync
        React.useEffect(() => {
             if (!showOnboarding && experienceInitialized) {
                 const htmlDisclaimer = document.getElementById('disclaimer-banner');
                 if (htmlDisclaimer && !htmlDisclaimer.classList.contains('hidden')) {
                     htmlDisclaimer.classList.add('hidden');
                     document.documentElement.style.setProperty('--disclaimer-height', '0px');
                 }
                 setShowDisclaimerInApp(true);
             } else {
                 setShowDisclaimerInApp(false);
             }
         }, [showOnboarding, experienceInitialized]);

        // --- Initialize the experience ---
        const initializeExperience = React.useCallback(() => {
            if (experienceInitialized) return;
            console.log("App: Initializing experience...");
            setIsLoading(true);

            let errorOccurred = false;
            const checkDependency = (depName, depVar) => { /* ... (keep dependency check logic) ... */ };
             // Add checks for all dependencies...
             checkDependency('AudioEngine', window.AudioEngine);
             checkDependency('AudioVisualConnector', window.AudioVisualConnector);
             checkDependency('VisualCanvas', window.VisualCanvas);
             checkDependency('VideoExporter', window.VideoExporter);
             checkDependency('EmotionAudioModules', window.EmotionAudioModules);
             checkDependency('EmotionVisualModules', window.EmotionVisualModules);
             checkDependency('AEPads', window.AEPads);
             checkDependency('VCLighting', window.VCLighting);


            if (!canvasRef.current) {
                 console.error("App: Canvas ref not available.");
                 if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Initialization Error: Canvas not ready.');
                 errorOccurred = true;
            }
            if (errorOccurred) {
                 setIsLoading(false);
                 if (typeof window.showErrorScreen === 'function') {
                      window.showErrorScreen('Core application files failed to load. Please check the console and refresh.');
                 }
                 return;
             }

            try {
                // 1. Init AudioEngine (Start paused)
                audioEngineRef.current = new AudioEngine(false, volume, currentMood);
                console.log("App: AudioEngine initialized.");

                // 2. Init Connector and link AudioEngine
                if (typeof AudioVisualConnector.getInstance !== 'function') throw new Error("AudioVisualConnector is not ready.");
                audioConnectorRef.current = AudioVisualConnector.getInstance();
                audioConnectorRef.current.setAudioEngine(audioEngineRef.current);
                audioConnectorRef.current.setMood(currentMood);
                console.log("App: AudioVisualConnector initialized and linked.");

                // 3. Init VisualCanvas
                visualCanvasRef.current = new VisualCanvas(canvasRef.current, currentMood);
                console.log("App: VisualCanvas initialized.");

                // 4. Init VideoExporter
                 if (audioEngineRef.current?.audioContext && audioEngineRef.current?.masterAnalyser) {
                     videoExporterRef.current = new VideoExporter(
                         canvasRef.current,
                         audioEngineRef.current.audioContext,
                         audioEngineRef.current.masterAnalyser
                     );
                     console.log("App: VideoExporter initialized.");
                 } else {
                     console.warn("App: VideoExporter could not be initialized.");
                     if (typeof ToastSystem !== 'undefined') ToastSystem.notify('warning', 'Video Exporter init failed.');
                 }

                setExperienceInitialized(true);

                // --- Start Playback Attempt ---
                setTimeout(() => {
                    setIsLoading(false);
                    const tryStartPlaying = async () => {
                        if (!audioEngineRef.current) return;
                        if (audioEngineRef.current.audioContext?.state === 'suspended') {
                             console.log("App: Attempting to resume suspended AudioContext...");
                             try {
                                 await audioEngineRef.current.audioContext.resume();
                                 console.log("App: AudioContext resumed by initialization.");
                                 setIsPlaying(true); // Trigger play via useEffect
                             } catch(e) {
                                 console.error("App: Error resuming audio context:", e);
                                 if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Could not start audio automatically. Click Play.');
                             }
                        } else if (audioEngineRef.current.audioContext?.state === 'running') {
                             setIsPlaying(true); // Trigger play via useEffect
                        } else {
                             console.warn("App: AudioContext not ready for auto-play:", audioEngineRef.current.audioContext?.state);
                        }
                    };
                    tryStartPlaying();
                }, 1500);

            } catch (error) {
                console.error("App: CRITICAL Error during experience initialization:", error);
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', `Initialization failed: ${error.message}. Please refresh.`);
                setIsLoading(false);
                setExperienceInitialized(false);
                audioEngineRef.current?.dispose();
                visualCanvasRef.current?.dispose();
                audioEngineRef.current = null;
                visualCanvasRef.current = null;
                audioConnectorRef.current = null;
                videoExporterRef.current = null;
                 if (typeof window.showErrorScreen === 'function') {
                      window.showErrorScreen(`Initialization failed (${error.message}). Please refresh.`);
                 }
            }
        }, [experienceInitialized, volume, currentMood]); // Dependencies

        // --- Effects to Update Instances ---
        React.useEffect(() => { // Update AudioEngine & Connector
            if (!experienceInitialized || !audioEngineRef.current) return;
            try {
                audioEngineRef.current.setPlaying(isPlaying, currentMood);
                if (audioEngineRef.current.volume !== volume) {
                    audioEngineRef.current.setVolume(volume);
                }
                // Trigger Look Around Hint
                if (isPlaying && !hintShownRef.current) {
                    setShowLookAroundHint(true);
                    hintShownRef.current = true; // Mark as shown
                }
            } catch(e) { console.error("App: Error updating AudioEngine state:", e); }
            if (audioConnectorRef.current) {
                 try { audioConnectorRef.current.setMood(currentMood); } catch(e) { console.error("App: Error updating Connector mood:", e); }
            }
        }, [isPlaying, currentMood, volume, experienceInitialized]); // Dependencies

        React.useEffect(() => { // Update VisualCanvas
             if (!experienceInitialized || !visualCanvasRef.current) return;
             try {
                 if (visualCanvasRef.current.currentMood !== currentMood) {
                     visualCanvasRef.current.changeMood(currentMood);
                 }
                 visualCanvasRef.current.animate(isPlaying);
             } catch(e) { console.error("App: Error updating VisualCanvas state:", e); }
        }, [isPlaying, currentMood, experienceInitialized]); // Dependencies

        // --- Event Handlers ---
        const handleEnterExperience = () => {
            const htmlDisclaimer = document.getElementById('disclaimer-banner');
            if (htmlDisclaimer && !htmlDisclaimer.classList.contains('hidden')) {
                 htmlDisclaimer.classList.add('hidden');
                 document.documentElement.style.setProperty('--disclaimer-height', '0px');
            }
            setShowOnboarding(false);
            setTimeout(initializeExperience, 50);
        };

        const togglePlayback = React.useCallback(() => {
             if (!experienceInitialized || !audioEngineRef.current) {
                  console.warn("App: Cannot toggle playback, experience not initialized.");
                  if (typeof ToastSystem !== 'undefined') ToastSystem.notify('warning', 'Experience not ready yet.');
                  return;
             }
             const nextIsPlaying = !isPlaying;
             if (nextIsPlaying && audioEngineRef.current.audioContext?.state === 'suspended') {
                 console.log("App: Attempting to resume AudioContext on play toggle...");
                 audioEngineRef.current.audioContext.resume()
                    .then(() => {
                         console.log("App: AudioContext resumed by toggle.");
                         setIsPlaying(true);
                    })
                    .catch(e => {
                         console.error("App: Error resuming audio context on toggle:", e);
                         if(typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Audio failed to start. Click/Tap again.');
                    });
             } else {
                 setIsPlaying(nextIsPlaying);
             }
        }, [experienceInitialized, isPlaying]);

        const handleVolumeChange = (e) => {
            if (!experienceInitialized) return;
            setVolume(parseFloat(e.target.value));
        };

        const handleMoodChange = React.useCallback((e) => {
            if (!experienceInitialized || isExporting) return;
            const newMood = e.target.value;
            if (newMood !== currentMood) {
                 setCurrentMood(newMood);
                 if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', `Mood changed to ${newMood.charAt(0).toUpperCase() + newMood.slice(1)}`);
            }
        }, [experienceInitialized, currentMood, isExporting]);

        const toggleExportPanel = React.useCallback(() => {
            if (isExporting) return;
            setShowExportPanel(prev => !prev);
        }, [isExporting]);

        const toggleUIVisibility = React.useCallback(() => {
          setUiVisible(prevUiVisible => {
              const nextUiVisible = !prevUiVisible;
              if (uiVisibilityTimeoutRef.current) {
                  clearTimeout(uiVisibilityTimeoutRef.current);
                  uiVisibilityTimeoutRef.current = null;
              }
              return nextUiVisible;
          });
        }, []);

        // --- Keyboard Shortcuts ---
        React.useEffect(() => {
          const handleKeyPress = (e) => {
            if (showOnboarding || !experienceInitialized || showExportPanel || isExporting ||
                document.activeElement?.tagName === 'INPUT' || document.activeElement?.tagName === 'SELECT' ||
                e.ctrlKey || e.altKey || e.metaKey) {
                 return;
            }

            const moodIndex = parseInt(e.key) - 1;
            if (!isNaN(moodIndex) && moodIndex >= 0 && moodIndex < availableMoods.length) {
                if (currentMood !== availableMoods[moodIndex].id) {
                    setCurrentMood(availableMoods[moodIndex].id);
                    if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', `Mood changed to ${availableMoods[moodIndex].label}`);
                }
                return;
            }

            switch (e.code) {
                case 'Space': e.preventDefault(); togglePlayback(); break;
                case 'KeyE': toggleExportPanel(); break;
                case 'KeyH': toggleUIVisibility(); break;
                case 'ArrowUp': e.preventDefault(); setVolume(prev => Math.min(1, prev + 0.05)); break;
                case 'ArrowDown': e.preventDefault(); setVolume(prev => Math.max(0, prev - 0.05)); break;
            }
          };

          if (experienceInitialized && !showOnboarding) {
              window.addEventListener('keydown', handleKeyPress);
          }
          return () => window.removeEventListener('keydown', handleKeyPress);
        }, [showOnboarding, experienceInitialized, showExportPanel, isExporting, togglePlayback, currentMood, availableMoods, toggleExportPanel, toggleUIVisibility, volume]);

        // --- Mouse Move for UI Visibility ---
        React.useEffect(() => {
          const handleInteraction = () => {
            if (uiVisibilityTimeoutRef.current) clearTimeout(uiVisibilityTimeoutRef.current);
            if (!uiVisible) setUiVisible(true);
            if (!showExportPanel) {
                 uiVisibilityTimeoutRef.current = setTimeout(() => {
                      if (!showExportPanel) setUiVisible(false);
                 }, 3000);
            }
          };
          if (experienceInitialized && !showOnboarding) {
            window.addEventListener('mousemove', handleInteraction);
            window.addEventListener('touchstart', handleInteraction, {passive: true});
            if (uiVisible && !showExportPanel) handleInteraction();
          }
          return () => {
            window.removeEventListener('mousemove', handleInteraction);
            window.removeEventListener('touchstart', handleInteraction);
            if (uiVisibilityTimeoutRef.current) clearTimeout(uiVisibilityTimeoutRef.current);
          };
        }, [uiVisible, showOnboarding, showExportPanel, experienceInitialized]);

        // --- Export Logic ---
        const handleExportQualityChange = (quality) => setExportQuality(quality);
        const handleExportFormatChange = (format) => setExportFormat(format);
        const handleExportDurationChange = (e) => {
          const duration = parseInt(e.target.value, 10);
          if (!isNaN(duration) && duration >= 5 && duration <= 1800) {
              setExportDuration(duration);
          } else if (!isNaN(duration)) {
               const clampedDuration = duration < 5 ? 5 : 1800;
               setExportDuration(clampedDuration);
               if (typeof ToastSystem !== 'undefined') ToastSystem.notify('warning', `Duration clamped to ${clampedDuration}s.`);
          }
        };

        const startExport = async () => {
            if (!experienceInitialized || !videoExporterRef.current) {
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', 'Cannot export: Experience or exporter not ready.');
                return;
            }
            if (isExporting) return;

            setIsExporting(true);
            setExportProgress(0);
            console.log(`App: Starting export - Duration: ${exportDuration}s, Quality: ${exportQuality}, Format: ${exportFormat}`);

            try {
                let audioStarted = false;
                if (!isPlaying || audioEngineRef.current?.audioContext?.state !== 'running') {
                    setIsPlaying(true);
                    if (audioEngineRef.current?.audioContext?.state === 'suspended') {
                         await audioEngineRef.current.audioContext.resume();
                         audioStarted = true;
                    }
                    await new Promise(resolve => setTimeout(resolve, audioStarted ? 500 : 100));
                }
                if (audioEngineRef.current?.audioContext?.state !== 'running') {
                     throw new Error("Audio context failed to start for recording.");
                }

                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', `Recording ${exportDuration}s video...`);
                await videoExporterRef.current.startRecording(exportQuality);

                const updateInterval = 100;
                const totalUpdates = Math.max(1, exportDuration * (1000 / updateInterval));
                let updateCount = 0;
                if (exportTimerRef.current) clearInterval(exportTimerRef.current);

                exportTimerRef.current = setInterval(() => {
                    if (!audioEngineRef.current || !isExporting) { // Check isExporting flag too
                         clearInterval(exportTimerRef.current);
                         exportTimerRef.current = null;
                         console.log("App: Export cancelled or component unmounted during recording.");
                         if (videoExporterRef.current && videoExporterRef.current.mediaRecorder && videoExporterRef.current.mediaRecorder.state !== 'inactive') {
                              videoExporterRef.current.mediaRecorder.stop();
                         }
                         setIsExporting(false);
                         setExportProgress(0);
                         return;
                    }
                    updateCount++;
                    const progress = Math.min((updateCount / totalUpdates) * 100, 99);
                    setExportProgress(progress);

                    if (updateCount >= totalUpdates) {
                        clearInterval(exportTimerRef.current);
                        exportTimerRef.current = null;
                        console.log("App: Recording timer finished, stopping recorder...");
                        finishExport();
                    }
                }, updateInterval);

            } catch (error) {
                console.error('App: Error starting export:', error);
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', `Failed to start recording: ${error.message}.`);
                setIsExporting(false);
                setExportProgress(0);
                if (exportTimerRef.current) clearInterval(exportTimerRef.current);
            }
        };

        const finishExport = async () => {
             if (!isExporting || !videoExporterRef.current) {
                 console.warn("App: finishExport called but not in exporting state or exporter missing.");
                 setIsExporting(false); setExportProgress(0); return;
             }
            try {
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', 'Stopping recorder & processing video...');
                const blob = await videoExporterRef.current.stopRecording();
                if (!blob || blob.size === 0) throw new Error("Recording resulted in an empty file.");

                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('info', 'Finalizing format...');
                const finalBlob = await videoExporterRef.current.convertToFormat(blob, exportFormat, (p) => setExportProgress(99 + p * 0.01));
                let finalExtension = 'webm';
                if (finalBlob.type.includes('mp4')) finalExtension = 'mp4';
                else if (finalBlob.type.includes('gif')) finalExtension = 'gif';

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const filename = `harmonic-visions-${currentMood}-${timestamp}.${finalExtension}`;
                const link = videoExporterRef.current.createDownloadLink(finalBlob, filename);
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
                URL.revokeObjectURL(link.href);

                setExportProgress(100);
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('success', `Video saved as ${filename}!`);
                setTimeout(() => { setIsExporting(false); setExportProgress(0); setShowExportPanel(false); }, 2000);

            } catch (error) {
                console.error('App: Error completing export:', error);
                if (typeof ToastSystem !== 'undefined') ToastSystem.notify('error', `Export failed: ${error.message}.`);
                setIsExporting(false); setExportProgress(0);
            }
        };

        // --- Enhanced Export Panel Component ---
         const EnhancedExportPanel = () => {
            const calculateEstimatedTime = () => `~${Math.ceil(exportDuration / 60 * 5)}m`; // Very rough estimate
            const formatDuration = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

            return (
                <div key={showExportPanel ? 'export-panel-visible' : 'export-panel-hidden'} className="panel active premium-panel">
                    <div className="panel-header">
                        <h2>Export Video</h2>
                        <button className="close-button" onClick={toggleExportPanel} disabled={isExporting} aria-label="Close export panel">×</button>
                    </div>
                    {isExporting ? (
                        <div className="progress-container">
                            <div className="progress-bar">
                                <div className="progress-fill" style={{ width: `${exportProgress}%` }}></div>
                                <div className="progress-glow" style={{ left: `${exportProgress}%` }}></div>
                            </div>
                            <div className="progress-text">{exportProgress < 99 ? `Recording: ${exportProgress.toFixed(0)}%` : 'Processing...'}</div>
                            <div className="progress-details">Please keep this tab active...</div>
                        </div>
                    ) : (
                        <>
                            <div className="setting-group">
                                <label htmlFor="duration-input">Duration (seconds)</label>
                                <input id="duration-input" type="number" min="5" max="1800" step="5" value={exportDuration} onChange={handleExportDurationChange} />
                            </div>
                            <div className="setting-group">
                                <label>Duration (mm:ss)</label>
                                <div>{formatDuration(exportDuration)}</div>
                            </div>
                            <div className="setting-group quality-group">
                                <label>Quality</label>
                                <div className="quality-options">
                                    {availableQualityOptions.map(opt => (
                                        <div key={opt.id} className={`quality-option ${exportQuality === opt.id ? 'selected' : ''}`} onClick={() => handleExportQualityChange(opt.id)} role="radio" aria-checked={exportQuality === opt.id} tabIndex="0" onKeyDown={(e) => e.key === 'Enter' && handleExportQualityChange(opt.id)}>
                                            <h4>{opt.label}</h4>
                                            <p>{ opt.id === 'low' ? 'Faster, smaller file' : opt.id === 'medium' ? 'Good balance' : opt.id === 'high' ? 'Better quality' : 'Best, larger file'}</p>
                                        </div>
                                    ))}
                                </div>
                            </div>
                             <div className="setting-group format-group">
                                <label>Format</label>
                                <div className="format-options">
                                    {availableFormatOptions.map(opt => (
                                        <div key={opt.id} className={`format-option ${exportFormat === opt.id ? 'selected' : ''}`} onClick={() => handleExportFormatChange(opt.id)} role="radio" aria-checked={exportFormat === opt.id} tabIndex="0" onKeyDown={(e) => e.key === 'Enter' && handleExportFormatChange(opt.id)}>
                                            <div className="format-icon">{ opt.id === 'webm' ? '🎬' : opt.id === 'mp4' ? ' M ' : ' G '}</div>
                                            <div className="format-label">{opt.label}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                             <div className="estimated-time">
                                 Note: MP4/GIF export often defaults to WebM due to browser limits.<br/>
                             </div>
                            <button className="action-button premium-button" onClick={startExport}><span className="button-text">Start Recording</span><span className="button-icon">🔴</span></button>
                        </>
                    )}
                </div>
            );
        };

        // --- Render ---
        return (
          <div key={showOnboarding ? 'onboarding' : 'experience'} className={`app-container ${!uiVisible ? 'ui-hidden' : ''}`}>
             {showDisclaimerInApp && <DisclaimerBanner />}

             {showOnboarding ? (
               <Onboarding moodDescriptions={availableMoodDescriptions} onEnter={handleEnterExperience} />
             ) : (
               <main className="main-content">
                 <div className="ui-hover-zone top"></div>
                 <div className="ui-hover-zone bottom"></div>

                 <header className="app-header premium-header">
                   <h1 className="app-title">Harmonic Visions</h1>
                   <div className="creator-badge"> FatStinkyPanda's Transcendence Experience <span className="support-text">Thanks for your support!</span> </div>
                 </header>

                 <canvas ref={canvasRef} className="visual-canvas" aria-label="Harmonic Visions Visual Experience" />

                 {/* Render Look Around Hint */}
                 <LookAroundHint
                     isVisible={showLookAroundHint}
                     onComplete={() => setShowLookAroundHint(false)} // Hide component after animation cycle
                 />

                 <div className="control-panel premium-controls" aria-label="Playback Controls">
                    <div className="control-group">
                        <button className="play-button" onClick={togglePlayback} disabled={!experienceInitialized} aria-label={isPlaying ? "Pause" : "Play"} title={isPlaying ? "Pause (Space)" : "Play (Space)"} > {isPlaying ? '❚❚' : '▶'} </button>
                    </div>
                    <div className="control-group">
                        <label htmlFor="volume">Volume</label>
                        <input id="volume" type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolumeChange} disabled={!experienceInitialized} aria-label="Volume Control (Up/Down Arrows)" className="premium-slider"/>
                    </div>
                    <div className="control-group">
                        <label htmlFor="mood">Mood</label>
                        <div className="mood-tooltip">{availableMoodDescriptions[currentMood] || 'Select a mood...'}</div>
                        <select id="mood" className="control-select premium-select" value={currentMood} onChange={handleMoodChange} disabled={!experienceInitialized || isExporting} aria-label="Select Mood (Keys 1-5)" >
                            {availableMoods.map(m => (<option key={m.id} value={m.id}>{m.label}</option>))}
                        </select>
                    </div>
                    <div className="control-group">
                        <button className="export-button premium-export" onClick={toggleExportPanel} disabled={isExporting || !experienceInitialized} title="Export Video (E)" >
                            <span className="export-button-icon">↓</span> Export Video
                        </button>
                    </div>
                 </div>

                 <div className="ui-toggle premium-toggle" onClick={toggleUIVisibility} title={uiVisible ? "Hide UI (H)" : "Show UI (H)"} role="button" aria-pressed={!uiVisible} aria-label="Toggle UI Visibility">
                     <span className="ui-toggle-icon">{uiVisible ? '◱' : '◰'}</span>
                 </div>

                 {showExportPanel && <EnhancedExportPanel />}

                 <div className="keyboard-shortcuts premium-shortcuts" aria-label="Keyboard Shortcuts">
                     Shortcuts: <span className="keyboard-shortcut">Space</span> Play/Pause | <span className="keyboard-shortcut">1-5</span> Mood | <span className="keyboard-shortcut">E</span> Export | <span className="keyboard-shortcut">H</span> Hide UI | <span className="keyboard-shortcut">↑↓</span> Volume
                 </div>
               </main>
             )}

             {isLoading && <LoadingIndicator />}
             <ToastContainer />
          </div>
        );
      } // End App component

      // --- React Render ---
      try {
        console.log("Attempting to render React application...");
        window.reactReady = false;
        ReactDOM.render(<App />, document.getElementById('root'), () => {
          console.log("React application rendered successfully.");
          window.reactReady = true;
          if (window.dependenciesLoaded && typeof window.hideInitialLoader === 'function') {
            hideInitialLoader();
          }
        });
      } catch (error) {
        console.error("React Render Error:", error);
        if (typeof window.hideInitialLoader === 'function') hideInitialLoader();
        if (typeof window.showErrorScreen === 'function') {
          window.showErrorScreen(`React failed to render (${error.message}). Please refresh.`);
        } else {
           document.body.innerHTML = `<div style='color:white; padding: 20px;'>Fatal Error: React failed to render. Please refresh. ${error.message}</div>`;
        }
      }
    </script>

</body>
</html>
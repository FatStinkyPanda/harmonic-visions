<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harmonic Visions: Transcendent Experience</title>
  <!-- Added favicon to prevent 404 error -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌌</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #2c3e50;
      --secondary-color: #3498db;
      --accent-color: #9b59b6;
      --accent-color-hover: #8e44ad;
      --background-color: #0a0a12;
      --text-color: #ecf0f1;
      --text-muted: rgba(236, 240, 241, 0.7);
      --control-background: rgba(10, 10, 18, 0.85);
      --control-border: rgba(52, 152, 219, 0.3);
      --panel-background: rgba(10, 10, 18, 0.95);
      --success-color: #2ecc71;
      --warning-color: #f39c12;
      --error-color: #e74c3c;
      --transition-fast: 0.2s;
      --transition-medium: 0.4s;
      --transition-slow: 0.8s;
      --border-radius: 12px;
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Montserrat', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      overflow: hidden;
      line-height: 1.6;
    }

    h1, h2, h3, h4, h5 {
      font-family: 'Playfair Display', serif;
      font-weight: 700;
      margin-bottom: 0.5em;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      position: relative;
    }

    .onboarding-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--panel-background);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity var(--transition-slow);
      overflow-y: auto; /* Allow vertical scrolling */
      padding: 40px 0; /* Add padding for better spacing */
    }

    .onboarding-container {
      width: 90%;
      max-width: 800px;
      position: relative;
      margin: 20px auto;
    }
    
    .onboarding-card {
      background: rgba(20, 20, 35, 0.9);
      border-radius: var(--border-radius);
      padding: 40px;
      box-shadow: var(--card-shadow);
      backdrop-filter: blur(10px);
      border: 1px solid var(--control-border);
      text-align: center;
      margin-bottom: 20px; /* Add bottom margin for scrolling space */
    }

    .onboarding-logo {
      font-size: 3rem;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #3498db, #9b59b6, #e74c3c);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 700;
    }

    .onboarding-subheading {
      font-size: 1.2rem;
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    .onboarding-description {
      margin-bottom: 2rem;
      font-size: 1rem;
      line-height: 1.7;
    }

    .creator-attribution {
      font-style: italic;
      margin-bottom: 2rem;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .experience-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .experience-card {
      background: rgba(30, 30, 50, 0.6);
      border-radius: var(--border-radius);
      padding: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
    }

    .experience-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
    }

    .experience-card h3 {
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .experience-card p {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .enter-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      padding: 12px 40px;
      font-size: 1.2rem;
      border-radius: 30px;
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      font-weight: 600;
      margin-top: 20px;
    }

    .enter-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
    }

    .enter-button:active {
      transform: translateY(1px);
    }

    .app-header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      z-index: 100;
      pointer-events: none;
    }

    .app-title {
      font-size: 1.5rem;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      pointer-events: auto;
      background: linear-gradient(135deg, #3498db, #9b59b6);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .creator-badge {
      background: rgba(10, 10, 18, 0.6);
      backdrop-filter: blur(10px);
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.8rem;
      pointer-events: auto;
      border: 1px solid var(--control-border);
    }

    .support-text {
      display: block;
      margin-top: 5px;
      font-size: 0.7rem;
      opacity: 0.7;
    }

    .main-content {
      position: relative;
      flex: 1;
    }

    .visual-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .control-panel {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--control-background);
      border-radius: var(--border-radius);
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 25px;
      z-index: 10;
      backdrop-filter: blur(15px);
      box-shadow: var(--card-shadow);
      border: 1px solid var(--control-border);
      transition: opacity var(--transition-medium);
      opacity: 0.85;
    }

    .control-panel:hover {
      opacity: 1;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .control-group label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
    }

    .mood-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel-background);
      padding: 10px 15px;
      border-radius: 8px;
      width: 250px;
      font-size: 0.85rem;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      pointer-events: none;
      margin-bottom: 10px;
      border: 1px solid var(--control-border);
    }

    .control-group:hover .mood-tooltip {
      opacity: 1;
      visibility: visible;
    }

    .play-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .play-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 15px rgba(155, 89, 182, 0.4);
    }
    
    .play-button:active {
      transform: scale(0.98);
    }

    input[type="range"] {
      -webkit-appearance: none;
      width: 120px;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--secondary-color);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: background-color var(--transition-fast);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--accent-color);
    }

    .control-select {
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 35px 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    .control-select:hover, .control-select:focus {
      border-color: var(--secondary-color);
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    .export-button {
      background: linear-gradient(135deg, #f39c12, #e74c3c);
      color: white;
      border: none;
      padding: 10px 18px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 600;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .export-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
    }

    .export-button-icon {
      font-size: 1.2rem;
    }

    .panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--panel-background);
      border-radius: var(--border-radius);
      padding: 30px;
      z-index: 20;
      backdrop-filter: blur(20px);
      box-shadow: var(--card-shadow);
      display: none;
      flex-direction: column;
      gap: 25px;
      width: 90%;
      max-width: 500px;
      border: 1px solid var(--control-border);
    }

    .panel.active {
      display: flex;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel h2 {
      font-size: 1.8rem;
      margin: 0;
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .close-button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.8rem;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity var(--transition-fast), color var(--transition-fast);
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
    }

    .close-button:hover {
      opacity: 1;
      color: white;
      background: rgba(255, 255, 255, 0.1);
    }

    .close-button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .setting-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .setting-group:last-child {
      border-bottom: none;
    }

    .setting-group label {
      font-weight: 500;
    }

    .setting-group input,
    .setting-group select {
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 10px 15px;
      border-radius: 8px;
      width: 180px;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    .setting-group input:hover,
    .setting-group select:hover,
    .setting-group input:focus,
    .setting-group select:focus {
      border-color: var(--secondary-color);
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    .setting-group input[type="number"] {
      text-align: right;
    }

    .setting-group input:disabled,
    .setting-group select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .setting-group select {
      padding-right: 35px;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
    }

    .estimated-time {
      font-size: 0.9rem;
      text-align: center;
      color: var(--text-muted);
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }

    .progress-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(to right, var(--secondary-color), var(--accent-color));
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .progress-text {
      text-align: center;
      font-weight: 500;
      color: var(--text-muted);
    }

    .action-button {
      background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
      color: white;
      border: none;
      padding: 14px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast);
      font-size: 1rem;
    }

    .action-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(155, 89, 182, 0.3);
    }

    .action-button:active {
      transform: translateY(0);
    }

    .action-button:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: translateY(0);
      box-shadow: none;
    }

    .quality-options {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .quality-option {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 10px;
      flex: 1;
      text-align: center;
      cursor: pointer;
      transition: background-color var(--transition-fast), transform var(--transition-fast);
      margin: 0 5px;
    }

    .quality-option:hover {
      background-color: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }

    .quality-option.selected {
      background-color: rgba(52, 152, 219, 0.3);
      border-color: var(--secondary-color);
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .quality-option h4 {
      margin: 0 0 5px 0;
      font-size: 0.9rem;
    }

    .quality-option p {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin: 0;
    }

    .format-options {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .format-option {
      flex: 1;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: background-color var(--transition-fast), transform var(--transition-fast);
    }

    .format-option:hover {
      background-color: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }

    .format-option.selected {
      background-color: rgba(52, 152, 219, 0.3);
      border-color: var(--secondary-color);
    }

    .format-icon {
      font-size: 1.5rem;
      margin-bottom: 5px;
    }

    .format-label {
      font-size: 0.85rem;
      font-weight: 500;
    }

    .keyboard-shortcuts {
      position: absolute;
      bottom: 15px;
      right: 15px;
      font-size: 0.8rem;
      color: var(--text-muted);
      background: rgba(10, 10, 18, 0.7);
      padding: 5px 10px;
      border-radius: 4px;
      z-index: 50;
    }

    .keyboard-shortcut {
      margin-left: 5px;
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      font-family: monospace;
    }

    .loading-indicator {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background-color);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      gap: 20px;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(52, 152, 219, 0.3);
      border-radius: 50%;
      border-top-color: var(--secondary-color);
      animation: spin 1s ease-in-out infinite;
    }

    .loading-text {
      font-size: 1.2rem;
      color: var(--text-muted);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 3000;
    }

    .toast {
      background: var(--panel-background);
      border-left: 4px solid var(--secondary-color);
      border-radius: 4px;
      padding: 15px 20px;
      margin-bottom: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      gap: 10px;
      animation: slide-in 0.3s ease-out forwards;
      max-width: 300px;
    }

    .toast.success {
      border-left-color: var(--success-color);
    }

    .toast.warning {
      border-left-color: var(--warning-color);
    }

    .toast.error {
      border-left-color: var(--error-color);
    }

    .toast-icon {
      font-size: 1.2rem;
    }

    .toast-success .toast-icon {
      color: var(--success-color);
    }

    .toast-warning .toast-icon {
      color: var(--warning-color);
    }

    .toast-error .toast-icon {
      color: var(--error-color);
    }

    .toast-message {
      flex: 1;
      font-size: 0.9rem;
    }

    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slide-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }

    .toast.removing {
      animation: slide-out 0.3s ease-in forwards;
    }

    /* Support section and message */
    .support-message {
      background: rgba(40, 40, 60, 0.5);
      border-radius: var(--border-radius);
      padding: 15px 20px;
      margin-top: 15px;
      border-left: 3px solid var(--secondary-color);
      font-size: 0.9rem;
      line-height: 1.5;
      text-align: left;
    }

    .support-message p {
      margin: 0;
    }

    /* Make sure Buy Me a Coffee widget doesn't overlap on mobile */
    @media (max-width: 480px) {
      #bmc-wbtn {
        bottom: 90px !important; /* Position above control panel */
        right: 10px !important;
        width: 50px !important;
        height: 50px !important;
      }
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      .onboarding-card {
        padding: 25px;
      }
      
      .onboarding-logo {
        font-size: 2.2rem;
      }
      
      .experience-cards {
        grid-template-columns: 1fr;
      }
      
      .control-panel {
        flex-direction: column;
        gap: 15px;
        padding: 15px;
        width: 90%;
      }
      
      .control-group {
        width: 100%;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      
      .mood-tooltip {
        left: auto;
        right: 0;
        transform: none;
      }
      
      .panel {
        width: 95%;
        padding: 20px;
      }
      
      .quality-options, 
      .format-options {
        flex-direction: column;
        gap: 10px;
      }
      
      .quality-option, 
      .format-option {
        margin: 0;
      }
      
      .setting-group {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .setting-group input,
      .setting-group select {
        width: 100%;
      }
      
      .app-title {
        font-size: 1.3rem;
      }
      
      .creator-badge {
        font-size: 0.7rem;
        padding: 6px 12px;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .control-panel {
        width: 80%;
      }
      
      .setting-group input,
      .setting-group select {
        width: 160px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Load React -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  
  <!-- Load Three.js and its dependencies in the correct order -->
  <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
  
  <!-- Load Three.js shaders and postprocessing effects -->
  <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FXAAShader.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Load Babel standalone for production transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel" data-presets="env,react">
    // Experience descriptions for different moods
    const moodDescriptions = {
      calm: "A serene journey through gentle landscapes bathed in soft blue light. The soundscape features calming water streams and gentle night sounds, perfect for relaxation and meditation.",
      soft: "Warm golden hues blend with peaceful melodies, creating a nurturing atmosphere that soothes the soul. Birdsong and gentle winds provide a comforting sanctuary for reflection.",
      uplifting: "Vibrant emerald landscapes pulse with energy and life. Dynamic rhythms and cheerful melodies inspire creativity and positive emotions, perfect for boosting your mood.",
      warm: "Enveloped in rose and amber tones, this experience recreates the feeling of being wrapped in love. Harmonies flow like a heartbeat, creating a deeply comforting atmosphere.",
      cosmic: "Journey beyond our world into the cosmic unknown. Deep purples and celestial patterns combine with ethereal sounds that expand consciousness and inspire wonder."
    };

    // Available mood options
    const moods = [
      { id: 'calm', label: 'Calm' },
      { id: 'soft', label: 'Soft' },
      { id: 'uplifting', label: 'Uplifting' },
      { id: 'warm', label: 'Warm' },
      { id: 'cosmic', label: 'Cosmic' }
    ];

    // Export quality options
    const qualityOptions = [
      { id: 'low', label: 'Low' },
      { id: 'medium', label: 'Medium' },
      { id: 'high', label: 'High' },
      { id: 'ultra', label: 'Ultra' }
    ];

    // Export format options
    const formatOptions = [
      { id: 'webm', label: 'WebM' },
      { id: 'mp4', label: 'MP4' },
      { id: 'gif', label: 'GIF' }
    ];

    // Toast notification system
    const ToastSystem = (() => {
      let toasts = [];
      let listeners = [];
      
      const subscribe = (listener) => {
        listeners.push(listener);
        return () => {
          listeners = listeners.filter(l => l !== listener);
        };
      };
      
      const notify = (type, message, duration = 3000) => {
        const id = Date.now();
        const toast = { id, type, message };
        toasts.push(toast);
        listeners.forEach(listener => listener(toasts));
        
        setTimeout(() => {
          removeToast(id);
        }, duration);
        
        return id;
      };
      
      const removeToast = (id) => {
        const toast = toasts.find(t => t.id === id);
        if (toast) {
          toast.removing = true;
          listeners.forEach(listener => listener([...toasts]));
          
          setTimeout(() => {
            toasts = toasts.filter(t => t.id !== id);
            listeners.forEach(listener => listener(toasts));
          }, 300);
        }
      };
      
      return {
        subscribe,
        notify,
        removeToast
      };
    })();

    // Toast Component
    const Toast = ({ type, message, removing, onClose }) => {
      const icons = {
        success: '✓',
        warning: '⚠',
        error: '✕',
        info: 'ℹ'
      };
      
      return (
        <div className={`toast toast-${type} ${removing ? 'removing' : ''}`}>
          <div className="toast-icon">{icons[type]}</div>
          <div className="toast-message">{message}</div>
        </div>
      );
    };

    // ToastContainer Component
    const ToastContainer = () => {
      const [toasts, setToasts] = React.useState([]);
      
      React.useEffect(() => {
        const unsubscribe = ToastSystem.subscribe(setToasts);
        return unsubscribe;
      }, []);
      
      return (
        <div className="toast-container">
          {toasts.map(toast => (
            <Toast
              key={toast.id}
              type={toast.type}
              message={toast.message}
              removing={toast.removing}
              onClose={() => ToastSystem.removeToast(toast.id)}
            />
          ))}
        </div>
      );
    };

    // Video Exporter Utility with improved audio sync
    class VideoExporter {
      constructor(canvas, audioContext, analyser) {
        this.canvas = canvas;
        this.audioContext = audioContext;
        this.analyser = analyser;
        this.mediaRecorder = null;
        this.chunks = [];
        this.stream = null;
        this.recordedTracks = [];
      }
      
      // Start recording
      async startRecording(quality = 'high') {
        try {
          // Ensure we can access the canvas
          if (!this.canvas) {
            throw new Error('Canvas is not available');
          }
          
          // Create canvas stream
          this.stream = this.canvas.captureStream(30); // 30 FPS
          
          // Get audio stream
          if (this.audioContext && this.analyser) {
            const audioDestination = this.audioContext.createMediaStreamDestination();
            this.analyser.connect(audioDestination);
            
            // Add audio tracks to the stream
            const audioTracks = audioDestination.stream.getAudioTracks();
            
            // Store original tracks for proper cleanup
            this.recordedTracks = [
              ...this.stream.getVideoTracks(),
              ...audioTracks
            ];
            
            // Add audio tracks to video stream
            audioTracks.forEach(track => this.stream.addTrack(track));
          } else {
            console.warn('Audio context or analyser not available. Video will be recorded without audio.');
            this.recordedTracks = [...this.stream.getVideoTracks()];
          }
          
          // Set media recorder options based on quality
          const options = this.getRecorderOptions(quality);
          
          // Create media recorder
          this.mediaRecorder = new MediaRecorder(this.stream, options);
          this.chunks = [];
          
          // Listen for data available events
          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) {
              this.chunks.push(e.data);
            }
          };
          
          // Start recording
          this.mediaRecorder.start(1000); // Collect data in 1-second chunks
          
          return this.mediaRecorder;
        } catch (error) {
          console.error('Error starting recording:', error);
          throw error;
        }
      }
      
      // Stop recording and get the recorded blob
      stopRecording() {
        return new Promise((resolve, reject) => {
          if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') {
            reject(new Error('No active recording'));
            return;
          }
          
          this.mediaRecorder.onstop = () => {
            try {
              // Create a single blob from all chunks
              const blob = new Blob(this.chunks, { type: this.mediaRecorder.mimeType });
              
              // Clean up resources
              this.chunks = [];
              
              // Properly stop all tracks
              this.recordedTracks.forEach(track => {
                if (track.readyState === 'live') {
                  track.stop();
                }
              });
              
              this.recordedTracks = [];
              this.stream = null;
              this.mediaRecorder = null;
              
              resolve(blob);
            } catch (error) {
              reject(error);
            }
          };
          
          this.mediaRecorder.stop();
        });
      }
      
      // Get a downloadable URL from the blob
      createDownloadLink(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        
        return link;
      }
      
      // Get recorder options based on quality
      getRecorderOptions(quality) {
        // Default options
        let options = {
          mimeType: 'video/webm',
          videoBitsPerSecond: 2500000 // 2.5 Mbps
        };
        
        // Adjust based on quality
        switch (quality) {
          case 'low':
            options.videoBitsPerSecond = 1500000; // 1.5 Mbps
            break;
          case 'medium':
            options.videoBitsPerSecond = 3000000; // 3 Mbps
            break;
          case 'high':
            options.videoBitsPerSecond = 6000000; // 6 Mbps
            break;
          case 'ultra':
            options.videoBitsPerSecond = 12000000; // 12 Mbps
            break;
          default:
            break;
        }
        
        // Try different codecs in order of preference
        const mimeTypes = [
          'video/webm;codecs=vp9,opus',
          'video/webm;codecs=vp8,opus',
          'video/webm;codecs=h264,opus',
          'video/webm',
          'video/mp4'
        ];
        
        for (const mimeType of mimeTypes) {
          if (MediaRecorder.isTypeSupported(mimeType)) {
            options.mimeType = mimeType;
            break;
          }
        }
        
        return options;
      }
      
      // Convert to different format if needed
      async convertToFormat(blob, format, progressCallback) {
        // In a real implementation, we'd use WebAssembly-based libraries like FFmpeg.js
        // For simplicity, we'll just return the blob as is
        progressCallback(100);
        
        // Format-specific handling
        if (format === 'mp4' && blob.type.includes('webm')) {
          // We can't actually convert here without FFmpeg.js
          // In a full implementation, this would convert WebM to MP4
          ToastSystem.notify('warning', 'MP4 conversion would require FFmpeg.js. Using WebM format instead.');
        } else if (format === 'gif') {
          // Same for GIF conversion
          ToastSystem.notify('warning', 'GIF conversion would require additional processing. Using WebM format instead.');
        }
        
        return blob;
      }
    }

    // Enhanced Audio Engine Component
    const moodAudioSettings = {
      calm: {
        tempo: 60, // BPM
        baseFreq: 220, // A3
        scale: 'pentatonic',
        harmonics: [1, 2, 3, 5, 8],
        attackTime: 1.5,
        releaseTime: 2.0,
        filterFreq: 800,
        filterQ: 2,
        modulationFreq: 0.12,
        modulationAmount: 10,
        reverbTime: 3.0,
        reverbDamping: 0.4,
        ambientSounds: ['water', 'night'],
        panning: true,
        ambientVolume: 0.25,
        melodyVolume: 0.2,
        padVolume: 0.3,
        bassVolume: 0.2,
      },
      soft: {
        tempo: 70, // BPM
        baseFreq: 261.63, // C4
        scale: 'major',
        harmonics: [1, 3, 5, 6, 8],
        attackTime: 1.0,
        releaseTime: 1.5,
        filterFreq: 1200,
        filterQ: 1,
        modulationFreq: 0.15,
        modulationAmount: 15,
        reverbTime: 2.0,
        reverbDamping: 0.3,
        ambientSounds: ['wind', 'birds'],
        panning: true,
        ambientVolume: 0.2,
        melodyVolume: 0.25,
        padVolume: 0.3,
        bassVolume: 0.2,
      },
      uplifting: {
        tempo: 95, // BPM
        baseFreq: 329.63, // E4
        scale: 'lydian',
        harmonics: [1, 2, 4, 5, 7],
        attackTime: 0.5,
        releaseTime: 1.0,
        filterFreq: 2000,
        filterQ: 1.5,
        modulationFreq: 0.2,
        modulationAmount: 20,
        reverbTime: 1.5,
        reverbDamping: 0.2,
        ambientSounds: ['birds', 'water'],
        panning: true,
        ambientVolume: 0.2,
        melodyVolume: 0.3,
        padVolume: 0.25,
        bassVolume: 0.25,
      },
      warm: {
        tempo: 75, // BPM
        baseFreq: 293.66, // D4
        scale: 'mixolydian',
        harmonics: [1, 2, 3, 4, 6],
        attackTime: 0.8,
        releaseTime: 1.2,
        filterFreq: 1500,
        filterQ: 1,
        modulationFreq: 0.12,
        modulationAmount: 12,
        reverbTime: 2.5,
        reverbDamping: 0.3,
        ambientSounds: ['fire', 'birds'],
        panning: true,
        ambientVolume: 0.2,
        melodyVolume: 0.25,
        padVolume: 0.35,
        bassVolume: 0.2,
      },
      cosmic: {
        tempo: 55, // BPM
        baseFreq: 174.61, // F3
        scale: 'phrygian',
        harmonics: [1, 3, 5, 7, 9],
        attackTime: 2.0,
        releaseTime: 3.0,
        filterFreq: 600,
        filterQ: 3,
        modulationFreq: 0.08,
        modulationAmount: 25,
        reverbTime: 4.0,
        reverbDamping: 0.5,
        ambientSounds: ['space', 'wind'],
        panning: true,
        ambientVolume: 0.3,
        melodyVolume: 0.2,
        padVolume: 0.35,
        bassVolume: 0.25,
      }
    };

    // Musical scales
    const musicalScales = {
      pentatonic: [0, 2, 4, 7, 9, 12, 14, 16, 19, 21, 24],
      major: [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24],
      minor: [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24],
      lydian: [0, 2, 4, 6, 7, 9, 11, 12, 14, 16, 18, 19, 21, 23, 24],
      mixolydian: [0, 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21, 22, 24],
      phrygian: [0, 1, 3, 5, 7, 8, 10, 12, 13, 15, 17, 19, 20, 22, 24]
    };

    const AudioEngine = React.forwardRef(({ isPlaying, volume, mood }, ref) => {
      // Audio context and nodes references
      const audioContextRef = React.useRef(null);
      const masterGainRef = React.useRef(null);
      const reverbNodeRef = React.useRef(null);
      const analyserNodeRef = React.useRef(null);
      const compressorRef = React.useRef(null);
      
      // Sound generators references
      const oscillatorsRef = React.useRef([]);
      const ambientSourcesRef = React.useRef([]);
      const melodicPatternRef = React.useRef(null);
      const bassPatternRef = React.useRef(null);
      const percussionPatternRef = React.useRef(null);
      
      // Audio data for visualization
      const audioDataRef = React.useRef(new Uint8Array(2048));
      
      // Expose audio context and analyzer for parent components
      React.useImperativeHandle(ref, () => ({
        audioContext: audioContextRef.current,
        analyser: analyserNodeRef.current,
        getAudioData: () => {
          if (analyserNodeRef.current) {
            analyserNodeRef.current.getByteFrequencyData(audioDataRef.current);
            return audioDataRef.current;
          }
          return null;
        }
      }));
      
      // Initialize audio context
      React.useEffect(() => {
        try {
          // Create audio context
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const context = new AudioContext({ latencyHint: 'interactive' });
          audioContextRef.current = context;
          
          // Create dynamics compressor for better overall sound
          const compressor = context.createDynamicsCompressor();
          compressor.threshold.value = -24;
          compressor.knee.value = 30;
          compressor.ratio.value = 12;
          compressor.attack.value = 0.003;
          compressor.release.value = 0.25;
          compressorRef.current = compressor;
          
          // Create main gain node
          const masterGain = context.createGain();
          masterGainRef.current = masterGain;
          masterGain.gain.value = volume;
          
          // Create analyzer node for visualization
          const analyser = context.createAnalyser();
          analyserNodeRef.current = analyser;
          analyser.fftSize = 2048;
          analyser.smoothingTimeConstant = 0.85;
          
          // Create convolver for reverb
          const reverb = context.createConvolver();
          reverbNodeRef.current = reverb;
          
          // Generate impulse response for reverb
          createReverb(context, 3.0, 0.2).then(buffer => {
            reverb.buffer = buffer;
          });
          
          // Connect nodes: Master Gain -> Reverb -> Compressor -> Analyser -> Output
          masterGain.connect(reverb);
          reverb.connect(compressor);
          compressor.connect(analyser);
          analyser.connect(context.destination);
          
          // Handle Safari: avoid initial suspension
          if (context.state === 'suspended') {
            const resumeContext = () => {
              context.resume();
              document.removeEventListener('click', resumeContext);
            };
            document.addEventListener('click', resumeContext);
          }
          
          return () => {
            // Clean up audio context and nodes
            stopAudio();
            if (context.state !== 'closed') {
              context.close();
            }
          };
        } catch (error) {
          console.error("Failed to initialize audio engine:", error);
          ToastSystem.notify('error', 'Failed to initialize audio. Please try reloading the page.');
        }
      }, []);
      
      // Update volume
      React.useEffect(() => {
        if (masterGainRef.current && audioContextRef.current) {
          masterGainRef.current.gain.setValueAtTime(
            volume,
            audioContextRef.current.currentTime
          );
        }
      }, [volume]);
      
      // Start/stop audio
      React.useEffect(() => {
        if (isPlaying) {
          // Resume audio context if suspended
          if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
            audioContextRef.current.resume().catch(error => {
              console.error("Failed to resume audio context:", error);
              ToastSystem.notify('error', 'Failed to start audio. Try clicking or tapping the screen first.');
            });
          }
          
          // Start audio generators
          startAudio(mood);
        } else {
          // Stop all sound sources
          stopAudio();
        }
        
        return () => {
          // Clean up when component unmounts or when isPlaying changes
          if (!isPlaying) {
            stopAudio();
          }
        };
      }, [isPlaying, mood]);
      
      // Update reverb when mood changes
      React.useEffect(() => {
        if (reverbNodeRef.current && audioContextRef.current && moodAudioSettings[mood]) {
          createReverb(
            audioContextRef.current,
            moodAudioSettings[mood].reverbTime,
            moodAudioSettings[mood].reverbDamping
          ).then(buffer => {
            reverbNodeRef.current.buffer = buffer;
          }).catch(error => {
            console.error("Failed to create reverb:", error);
          });
        }
      }, [mood]);
      
      // Create enhanced reverb impulse response
      const createReverb = async (context, duration, damping = 0.4) => {
        const sampleRate = context.sampleRate;
        const length = sampleRate * duration;
        const impulseResponse = context.createBuffer(2, length, sampleRate);
        
        const leftChannel = impulseResponse.getChannelData(0);
        const rightChannel = impulseResponse.getChannelData(1);
        
        // Create more realistic reverb with initial reflections and decay
        for (let i = 0; i < length; i++) {
          // Early reflections (first 50ms)
          if (i < sampleRate * 0.05) {
            const reflectionStrength = Math.random() * 0.5 * Math.exp(-i / (sampleRate * 0.02));
            leftChannel[i] = (Math.random() * 2 - 1) * reflectionStrength;
            rightChannel[i] = (Math.random() * 2 - 1) * reflectionStrength;
          } 
          // Main decay
          else {
            // Decay curve with frequency-dependent damping
            const decay = Math.exp(-i / (sampleRate * duration * (1 - damping * 0.5)));
            
            // Add some subtle modulation to create a more organic sound
            const modulation = 1 + 0.1 * Math.sin(i * 0.0001);
            
            // Stereo field enhancement
            const stereoSpread = 0.3;
            const leftSample = (Math.random() * 2 - 1) * decay * modulation;
            const rightSample = (Math.random() * 2 - 1) * decay * modulation;
            
            // Mix for stereo spread
            leftChannel[i] = leftSample * (1 - stereoSpread/2) + rightSample * stereoSpread/2;
            rightChannel[i] = rightSample * (1 - stereoSpread/2) + leftSample * stereoSpread/2;
          }
        }
        
        return impulseResponse;
      };
      
      // Start audio generators
      const startAudio = (currentMood) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        const settings = moodAudioSettings[currentMood];
        
        if (!context || !masterGain || !settings) {
          console.error("Audio context, master gain, or settings not available");
          return;
        }
        
        // Stop any currently playing sounds
        stopAudio();
        
        try {
          // Create ambient sound layers
          createAmbientLayers(settings);
          
          // Create drone/pad sound
          createDronePad(settings);
          
          // Create bass pattern
          createBassPattern(settings);
          
          // Create melodic pattern
          createMelodicPattern(settings);
          
          // Create subtle percussion (if not calm or cosmic mood)
          if (currentMood !== 'calm' && currentMood !== 'cosmic') {
            createPercussionPattern(settings);
          }
        } catch (error) {
          console.error("Error starting audio:", error);
          ToastSystem.notify('error', 'An error occurred while creating audio elements');
        }
      };
      
      // Stop all audio generators
      const stopAudio = () => {
        // Stop oscillators
        oscillatorsRef.current.forEach(osc => {
          try {
            if (osc.stop && typeof osc.stop === 'function') {
              osc.stop();
            }
            if (osc.disconnect && typeof osc.disconnect === 'function') {
              osc.disconnect();
            }
          } catch (e) {
            // Oscillator might be already stopped
          }
        });
        oscillatorsRef.current = [];
        
        // Stop ambient sources
        ambientSourcesRef.current.forEach(source => {
          try {
            if (source.stop && typeof source.stop === 'function') {
              source.stop();
            }
            if (source.disconnect && typeof source.disconnect === 'function') {
              source.disconnect();
            }
          } catch (e) {
            // Source might be already stopped
          }
        });
        ambientSourcesRef.current = [];
        
        // Stop patterns
        [melodicPatternRef, bassPatternRef, percussionPatternRef].forEach(ref => {
          if (ref.current) {
            clearInterval(ref.current);
            ref.current = null;
          }
        });
      };
      
      // Create advanced ambient sound layers
      const createAmbientLayers = (settings) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        
        if (!context || !masterGain) return;
        
        settings.ambientSounds.forEach((type, index) => {
          // Create stereo panner for spatial positioning
          const panner = context.createStereoPanner();
          panner.pan.value = settings.panning ? (index % 2 === 0 ? -0.3 : 0.3) : 0;
          
          // Create white noise source for base ambient sounds
          const bufferSize = 2 * context.sampleRate;
          const noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
          const output = noiseBuffer.getChannelData(0);
          
          // Generate noise based on ambient type
          switch (type) {
            case 'water':
              // Water flowing sound (filtered noise with modulation)
              for (let i = 0; i < bufferSize; i++) {
                // Combine multiple noise frequencies for natural water sound
                const highFreq = Math.random() * 2 - 1;
                const midFreq = Math.random() * 2 - 1;
                const lowFreq = Math.random() * 2 - 1;
                
                // Water has more mid and low frequencies than pure white noise
                output[i] = (highFreq * 0.2 + midFreq * 0.5 + lowFreq * 0.3) * 
                            (0.7 + 0.3 * Math.sin(i / 20000)); // Subtle wave pattern
              }
              break;
            
            case 'wind':
              // Wind sound (filtered noise with slow modulation)
              for (let i = 0; i < bufferSize; i++) {
                // Wind has a "whistling" quality created by filtered noise
                const noise = Math.random() * 2 - 1;
                // Slow amplitude modulation creates gusts
                const gustIntensity = 0.5 + 0.5 * Math.sin(i / 40000) + 0.2 * Math.sin(i / 12000);
                // Frequency modulation creates the whistling effect
                const whistling = 0.1 * Math.sin(i / (1000 + 500 * Math.sin(i / 25000)));
                
                output[i] = noise * gustIntensity + whistling;
              }
              break;
            
            case 'birds':
              // Birds chirping (random chirps over quiet background)
              let lastChirpTime = 0;
              for (let i = 0; i < bufferSize; i++) {
                // Background ambient noise (very quiet)
                output[i] = Math.random() * 0.03;
                
                // Occasionally generate a bird chirp
                if (i - lastChirpTime > 10000 && Math.random() > 0.9995) {
                  // Start of chirp sequence
                  lastChirpTime = i;
                  
                  // Each bird has a different chirp pattern
                  const chirpCount = 2 + Math.floor(Math.random() * 5);
                  const chirpBaseFreq = 2000 + Math.random() * 3000; // Hz, higher frequency for birds
                  
                  for (let c = 0; c < chirpCount; c++) {
                    const chirpStart = i + c * 2000 * Math.random();
                    const chirpLength = 300 + Math.random() * 500;
                    
                    if (chirpStart + chirpLength < bufferSize) {
                      // Generate a single chirp
                      for (let j = 0; j < chirpLength; j++) {
                        const position = chirpStart + j;
                        const envelope = Math.sin((j / chirpLength) * Math.PI);
                        const chirpFreq = chirpBaseFreq * (1 + 0.2 * Math.sin(j / 30));
                        
                        output[Math.floor(position)] += 
                          Math.sin(j * (chirpFreq / context.sampleRate) * Math.PI * 2) * 
                          envelope * 0.25;
                      }
                    }
                  }
                }
              }
              break;
            
            case 'fire':
              // Fire crackling (random bursts of noise)
              for (let i = 0; i < bufferSize; i++) {
                // Base fire sound (low rumble)
                const baseFire = Math.random() * 0.1;
                
                // Random crackling
                let crackle = 0;
                if (Math.random() > 0.995) {
                  // Create a crackle
                  for (let j = 0; j < 500 && i + j < bufferSize; j++) {
                    // Sharp attack, quick decay
                    const envelope = Math.exp(-j / 100);
                    output[i + j] += (Math.random() * 2 - 1) * envelope * 0.4;
                  }
                }
                
                output[i] += baseFire;
              }
              break;
            
            case 'night':
              // Night sounds (crickets, occasional owl, etc.)
              for (let i = 0; i < bufferSize; i++) {
                // Very quiet background
                output[i] = Math.random() * 0.02;
                
                // Cricket chirps (repeating pattern)
                if (i % 20000 < 2000 && i % 250 < 50) {
                  const chirpEnvelope = Math.sin((i % 250) / 50 * Math.PI);
                  output[i] += Math.sin(i * 0.3) * chirpEnvelope * 0.15;
                }
                
                // Occasional owl hoot
                if (Math.random() > 0.9999) {
                  for (let j = 0; j < 5000 && i + j < bufferSize; j++) {
                    const hootEnvelope = Math.sin((j / 5000) * Math.PI);
                    const hootFreq = 300 + 50 * Math.sin(j / 1000);
                    output[i + j] += Math.sin(j * (hootFreq / context.sampleRate) * 
                                    Math.PI * 2) * hootEnvelope * 0.2;
                  }
                }
              }
              break;
            
            case 'space':
              // Space ambient (low drones, occasional swooshes)
              for (let i = 0; i < bufferSize; i++) {
                // Deep space background (filtered noise)
                const spaceNoise = Math.random() * 2 - 1;
                
                // Very low frequency modulation
                const spaceMod = 0.1 + 0.1 * Math.sin(i / 100000);
                
                // Occasional ethereal tones
                let toneSweep = 0;
                if (i % 200000 < 30000) {
                  const sweepPhase = (i % 200000) / 30000;
                  const sweepFreq = 100 + sweepPhase * 200;
                  const sweepEnvelope = 0.5 * 
                                      Math.sin(sweepPhase * Math.PI) * 
                                      (0.5 + 0.5 * Math.sin(sweepPhase * 20 * Math.PI));
                  
                  toneSweep = Math.sin(i * (sweepFreq / context.sampleRate) * 
                              Math.PI * 2) * sweepEnvelope * 0.1;
                }
                
                output[i] = spaceNoise * spaceMod * 0.1 + toneSweep;
              }
              break;
            
            default:
              // Default white noise
              for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
              }
          }
          
          // Create audio source from noise buffer
          const source = context.createBufferSource();
          source.buffer = noiseBuffer;
          source.loop = true;
          
          // Create filter for shaping the sound
          const filter = context.createBiquadFilter();
          
          // Configure filter based on ambient type
          switch (type) {
            case 'water':
              filter.type = 'lowpass';
              filter.frequency.value = 800;
              filter.Q.value = 1;
              
              // Add LFO for water movement
              const waterLFO = context.createOscillator();
              const waterLFOGain = context.createGain();
              waterLFO.frequency.value = 0.1;
              waterLFOGain.gain.value = 100;
              waterLFO.connect(waterLFOGain);
              waterLFOGain.connect(filter.frequency);
              waterLFO.start();
              oscillatorsRef.current.push(waterLFO);
              break;
              
            case 'wind':
              filter.type = 'bandpass';
              filter.frequency.value = 500;
              filter.Q.value = 2;
              
              // More complex LFO system for wind
              const windLFO1 = context.createOscillator();
              const windLFO2 = context.createOscillator();
              const windLFOGain = context.createGain();
              
              windLFO1.frequency.value = 0.1;
              windLFO2.frequency.value = 0.05;
              
              const windLFO1Gain = context.createGain();
              const windLFO2Gain = context.createGain();
              
              windLFO1Gain.gain.value = 200;
              windLFO2Gain.gain.value = 100;
              
              windLFO1.connect(windLFO1Gain);
              windLFO2.connect(windLFO2Gain);
              
              windLFO1Gain.connect(windLFOGain);
              windLFO2Gain.connect(windLFOGain);
              
              windLFOGain.connect(filter.frequency);
              
              windLFO1.start();
              windLFO2.start();
              
              oscillatorsRef.current.push(windLFO1);
              oscillatorsRef.current.push(windLFO2);
              break;
              
            case 'birds':
              // High-pass to emphasize the chirps
              filter.type = 'highpass';
              filter.frequency.value = 2000;
              filter.Q.value = 1;
              
              // Add a second bandpass filter for the characteristic bird sound
              const birdFilter2 = context.createBiquadFilter();
              birdFilter2.type = 'bandpass';
              birdFilter2.frequency.value = 3500;
              birdFilter2.Q.value = 2;
              
              filter.connect(birdFilter2);
              // Use birdFilter2 for future connections
              source.connect(filter);
              filter.connect(birdFilter2);
              birdFilter2.connect(panner);
              panner.connect(masterGain);
              
              // Store references for cleanup
              ambientSourcesRef.current.push(source);
              
              // Skip the rest of the processing as we've already connected everything
              return;
              
            case 'fire':
              // Layered filters for fire
              filter.type = 'lowpass';
              filter.frequency.value = 4000;  // Allow higher frequencies for crackling
              
              const fireFilter2 = context.createBiquadFilter();
              fireFilter2.type = 'bandpass';
              fireFilter2.frequency.value = 1500; // Mid frequencies for the base fire sound
              fireFilter2.Q.value = 0.8;
              
              // Modulate filter frequency for live fire effect
              const fireLFO = context.createOscillator();
              const fireLFOGain = context.createGain();
              fireLFO.frequency.value = 0.3;
              fireLFOGain.gain.value = 400;
              fireLFO.connect(fireLFOGain);
              fireLFOGain.connect(fireFilter2.frequency);
              fireLFO.start();
              
              // Connect the first filter to the second
              source.connect(filter);
              filter.connect(fireFilter2);
              fireFilter2.connect(panner);
              panner.connect(masterGain);
              
              oscillatorsRef.current.push(fireLFO);
              ambientSourcesRef.current.push(source);
              
              // Skip the rest of the processing as we've already connected everything
              return;
              
            case 'night':
              // Combined filters for night sounds
              filter.type = 'bandpass';
              filter.frequency.value = 3000;
              filter.Q.value = 5;
              
              // Add a second filter for the lower sounds (owls)
              const nightFilter2 = context.createBiquadFilter();
              nightFilter2.type = 'lowpass';
              nightFilter2.frequency.value = 400;
              
              // Create a gain for the second filter path
              const nightLowGain = context.createGain();
              nightLowGain.gain.value = 0.6;
              
              // Split the signal
              source.connect(filter);
              filter.connect(panner);
              source.connect(nightFilter2);
              nightFilter2.connect(nightLowGain);
              nightLowGain.connect(panner);
              panner.connect(masterGain);
              
              ambientSourcesRef.current.push(source);
              
              // Skip the rest of the processing as we've already connected everything
              return;
              
            case 'space':
              // Complex filter arrangement for space sounds
              filter.type = 'lowpass';
              filter.frequency.value = 200;
              filter.Q.value = 5;
              
              // Add a second bandpass filter for ethereal tones
              const spaceFilter2 = context.createBiquadFilter();
              spaceFilter2.type = 'bandpass';
              spaceFilter2.frequency.value = 700;
              spaceFilter2.Q.value = 8;
              
              // Create a gain for the second filter path
              const spaceToneGain = context.createGain();
              spaceToneGain.gain.value = 0.3;
              
              // LFO for sweeping the bandpass
              const spaceLFO = context.createOscillator();
              const spaceLFOGain = context.createGain();
              spaceLFO.frequency.value = 0.02; // Very slow
              spaceLFOGain.gain.value = 300;
              spaceLFO.connect(spaceLFOGain);
              spaceLFOGain.connect(spaceFilter2.frequency);
              spaceLFO.start();
              
              // Split the signal
              source.connect(filter);
              filter.connect(panner);
              source.connect(spaceFilter2);
              spaceFilter2.connect(spaceToneGain);
              spaceToneGain.connect(panner);
              panner.connect(masterGain);
              
              oscillatorsRef.current.push(spaceLFO);
              ambientSourcesRef.current.push(source);
              
              // Skip the rest of the processing as we've already connected everything
              return;
              
            default:
              filter.type = 'lowpass';
              filter.frequency.value = 1000;
          }
          
          // Create gain for the ambient sound
          const ambientGain = context.createGain();
          ambientGain.gain.value = settings.ambientVolume; // Set from mood settings
          
          // Create an EQ section (using multiple filters)
          const lowEQ = context.createBiquadFilter();
          const midEQ = context.createBiquadFilter();
          const highEQ = context.createBiquadFilter();
          
          lowEQ.type = 'lowshelf';
          lowEQ.frequency.value = 300;
          lowEQ.gain.value = type === 'water' || type === 'fire' ? 3 : 0; // Boost lows for water and fire
          
          midEQ.type = 'peaking';
          midEQ.frequency.value = 1000;
          midEQ.Q.value = 1;
          midEQ.gain.value = type === 'birds' ? 3 : (type === 'night' ? -3 : 0); // EQ adjustments by type
          
          highEQ.type = 'highshelf';
          highEQ.frequency.value = 3000;
          highEQ.gain.value = type === 'birds' ? 5 : (type === 'space' ? -5 : 0); // EQ adjustments by type
          
          // Connect all the nodes
          source.connect(filter);
          filter.connect(lowEQ);
          lowEQ.connect(midEQ);
          midEQ.connect(highEQ);
          highEQ.connect(ambientGain);
          ambientGain.connect(panner);
          panner.connect(masterGain);
          
          // Start the source
          source.start(0);
          
          // Store references for cleanup
          ambientSourcesRef.current.push(source);
        });
      };
      
      // Create enhanced drone/pad sound
      const createDronePad = (settings) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        
        if (!context || !masterGain) return;
        
        // Create a separate gain node for all pad elements
        const padMasterGain = context.createGain();
        padMasterGain.gain.value = settings.padVolume;
        padMasterGain.connect(masterGain);
        
        // Add a subtle chorus effect
        const chorus = createChorus(context);
        
        // Create oscillators for each harmonic
        settings.harmonics.forEach((harmonic, idx) => {
          // Create and configure a gain node for this harmonic
          const oscGain = context.createGain();
          oscGain.gain.value = 0; // Will be ramped up
          
          // Calculate slight detuning for each oscillator instance to create a richer sound
          const detune1 = -5 + Math.random() * 10;
          const detune2 = -5 + Math.random() * 10;
          
          // Create two slightly detuned oscillators per harmonic for richness
          const createPadOscillator = (detune, pan = 0) => {
            // Create and configure oscillator
            const osc = context.createOscillator();
            
            // Alternate between waveforms for different harmonics
            const waveforms = ['sine', 'triangle', 'sine', 'triangle', 'sine'];
            osc.type = waveforms[idx % waveforms.length];
            
            // Apply frequency and detune
            osc.frequency.value = settings.baseFreq * harmonic;
            osc.detune.value = detune;
            
            // Create a filter for this oscillator
            const oscFilter = context.createBiquadFilter();
            oscFilter.type = 'lowpass';
            oscFilter.frequency.value = settings.filterFreq / (harmonic * 0.5);
            oscFilter.Q.value = settings.filterQ * (1 - idx * 0.1);
            
            // Create a panner for stereo spread
            const oscPanner = context.createStereoPanner();
            oscPanner.pan.value = pan;
            
            // Create an LFO for subtle movement
            const lfo = context.createOscillator();
            // Different LFO speeds for each oscillator
            lfo.frequency.value = settings.modulationFreq * (1 + 0.3 * Math.random() - 0.15);
            
            const lfoGain = context.createGain();
            lfoGain.gain.value = settings.modulationAmount * (1 / (harmonic * 0.3));
            
            // Connect LFO to oscillator frequency for vibrato
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            
            // Connect everything
            osc.connect(oscFilter);
            oscFilter.connect(oscPanner);
            oscPanner.connect(oscGain);
            
            // Start oscillator and LFO
            osc.start(0);
            lfo.start(0);
            
            // Store for cleanup
            oscillatorsRef.current.push(osc);
            oscillatorsRef.current.push(lfo);
            
            return { osc, lfo, filter: oscFilter };
          };
          
          // Create the two detuned oscillators with opposite panning
          const osc1 = createPadOscillator(detune1, -0.2 * (idx % 2 ? 1 : -1));
          const osc2 = createPadOscillator(detune2, 0.2 * (idx % 2 ? 1 : -1));
          
          // Connect the oscillator gain to chorus and then to the pad master gain
          oscGain.connect(chorus.input);
          
          // Apply volume curve based on harmonic number (lower harmonics louder)
          const harmonicVolume = 0.15 / Math.sqrt(idx + 1);
          
          // Fade in the gain with an appropriate envelope
          oscGain.gain.setValueAtTime(0, context.currentTime);
          oscGain.gain.linearRampToValueAtTime(
            harmonicVolume,
            context.currentTime + settings.attackTime * (1 + idx * 0.2) // Stagger attacks
          );
        });
        
        // Connect chorus to pad master gain
        chorus.output.connect(padMasterGain);
      };
      
      // Create a simple chorus effect
      const createChorus = (context) => {
        // Delay lines
        const delay1 = context.createDelay();
        const delay2 = context.createDelay();
        
        delay1.delayTime.value = 0.025;
        delay2.delayTime.value = 0.02;
        
        // LFOs to modulate the delay times
        const lfo1 = context.createOscillator();
        const lfo2 = context.createOscillator();
        
        const lfo1Gain = context.createGain();
        const lfo2Gain = context.createGain();
        
        lfo1.frequency.value = 0.6;
        lfo2.frequency.value = 0.7;
        
        lfo1Gain.gain.value = 0.005;
        lfo2Gain.gain.value = 0.004;
        
        lfo1.connect(lfo1Gain);
        lfo2.connect(lfo2Gain);
        
        lfo1Gain.connect(delay1.delayTime);
        lfo2Gain.connect(delay2.delayTime);
        
        // Gain nodes for delay lines
        const delay1Gain = context.createGain();
        const delay2Gain = context.createGain();
        
        delay1Gain.gain.value = 0.33;
        delay2Gain.gain.value = 0.33;
        
        // Input and output nodes
        const input = context.createGain();
        const output = context.createGain();
        
        // Wet/dry mix
        const dryGain = context.createGain();
        dryGain.gain.value = 0.5;
        
        // Connections
        input.connect(dryGain);
        dryGain.connect(output);
        
        input.connect(delay1);
        input.connect(delay2);
        
        delay1.connect(delay1Gain);
        delay2.connect(delay2Gain);
        
        delay1Gain.connect(output);
        delay2Gain.connect(output);
        
        // Start LFOs
        lfo1.start();
        lfo2.start();
        
        // Store for cleanup
        oscillatorsRef.current.push(lfo1);
        oscillatorsRef.current.push(lfo2);
        
        return { input, output };
      };
      
      // Create bass pattern
      const createBassPattern = (settings) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        
        if (!context || !masterGain) return;
        
        // Clear any existing pattern
        if (bassPatternRef.current) {
          clearInterval(bassPatternRef.current);
        }
        
        // Create a gain node for the bass
        const bassGain = context.createGain();
        bassGain.gain.value = settings.bassVolume;
        
        // Create filter and compressor for bass
        const bassFilter = context.createBiquadFilter();
        bassFilter.type = 'lowpass';
        bassFilter.frequency.value = 300;
        bassFilter.Q.value = 0.7;
        
        const bassCompressor = context.createDynamicsCompressor();
        bassCompressor.threshold.value = -24;
        bassCompressor.knee.value = 10;
        bassCompressor.ratio.value = 12;
        bassCompressor.attack.value = 0.005;
        bassCompressor.release.value = 0.25;
        
        // Connect nodes
        bassGain.connect(bassFilter);
        bassFilter.connect(bassCompressor);
        bassCompressor.connect(masterGain);
        
        // Get scale for current mood
        const scale = musicalScales[settings.scale] || musicalScales.pentatonic;
        
        // Calculate tempo-related values
        const tempo = settings.tempo;
        const beatDuration = 60 / tempo;
        const noteDuration = beatDuration * 2; // Half-notes for bass typically
        
        // Create bass pattern based on mood
        let bassPattern;
        const baseNote = 0; // Root note
        
        switch (mood) {
          case 'calm':
            bassPattern = [baseNote, baseNote, baseNote + 7, baseNote + 5];
            break;
          case 'soft':
            bassPattern = [baseNote, baseNote + 5, baseNote + 3, baseNote + 5];
            break;
          case 'uplifting':
            bassPattern = [baseNote, baseNote + 7, baseNote + 9, baseNote + 5];
            break;
          case 'warm':
            bassPattern = [baseNote, baseNote + 5, baseNote + 3, baseNote];
            break;
          case 'cosmic':
            bassPattern = [baseNote, baseNote + 2, baseNote + 5, baseNote + 3];
            break;
          default:
            bassPattern = [baseNote, baseNote + 5, baseNote + 7, baseNote + 5];
        }
        
        let patternIndex = 0;
        
        // Function to play a single bass note
        const playBassNote = () => {
          // Basic bass note with sub-oscillator
          const noteIndex = bassPattern[patternIndex];
          patternIndex = (patternIndex + 1) % bassPattern.length;
          
          // Calculate frequency: two octaves below the base
          const frequency = settings.baseFreq * 0.25 * Math.pow(2, noteIndex / 12);
          
          // Create oscillators (layered for richness)
          // Base sub-oscillator (sine wave, one octave down)
          const subOsc = context.createOscillator();
          subOsc.type = 'sine';
          subOsc.frequency.value = frequency * 0.5;
          
          // Main oscillator (can be triangle or sawtooth depending on mood)
          const mainOsc = context.createOscillator();
          mainOsc.type = mood === 'uplifting' ? 'sawtooth' : 'triangle';
          mainOsc.frequency.value = frequency;
          
          // Upper harmonic (adds definition)
          const harmOsc = context.createOscillator();
          harmOsc.type = 'sine';
          harmOsc.frequency.value = frequency * 2;
          
          // Create gain nodes for each oscillator
          const subGain = context.createGain();
          const mainGain = context.createGain();
          const harmGain = context.createGain();
          
          // Set relative volumes
          subGain.gain.value = 0.6;
          mainGain.gain.value = 0.4;
          harmGain.gain.value = 0.15;
          
          // Connect oscillators to their respective gain nodes
          subOsc.connect(subGain);
          mainOsc.connect(mainGain);
          harmOsc.connect(harmGain);
          
          // Connect all gain nodes to the bass gain
          subGain.connect(bassGain);
          mainGain.connect(bassGain);
          harmGain.connect(bassGain);
          
          // Create envelopes
          const createEnvelope = (gainNode, attackTime, releaseTime) => {
            gainNode.gain.setValueAtTime(0, context.currentTime);
            gainNode.gain.linearRampToValueAtTime(
              gainNode.gain.value,
              context.currentTime + attackTime
            );
            
            gainNode.gain.setValueAtTime(
              gainNode.gain.value,
              context.currentTime + noteDuration - releaseTime
            );
            
            gainNode.gain.linearRampToValueAtTime(
              0,
              context.currentTime + noteDuration
            );
          };
          
          // Apply envelopes
          createEnvelope(subGain, 0.05, 0.2);
          createEnvelope(mainGain, 0.02, 0.15);
          createEnvelope(harmGain, 0.01, 0.1);
          
          // Start oscillators
          subOsc.start(context.currentTime);
          mainOsc.start(context.currentTime);
          harmOsc.start(context.currentTime);
          
          // Stop oscillators
          const stopTime = context.currentTime + noteDuration + 0.1;
          subOsc.stop(stopTime);
          mainOsc.stop(stopTime);
          harmOsc.stop(stopTime);
          
          // Store for cleanup
          oscillatorsRef.current.push(subOsc);
          oscillatorsRef.current.push(mainOsc);
          oscillatorsRef.current.push(harmOsc);
        };
        
        // Initial bass note
        playBassNote();
        
        // Schedule remaining bass notes
        bassPatternRef.current = setInterval(() => {
          if (isPlaying) {
            playBassNote();
          }
        }, noteDuration * 1000);
      };
      
      // Create melodic pattern
      const createMelodicPattern = (settings) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        
        if (!context || !masterGain) return;
        
        // Clear any existing pattern
        if (melodicPatternRef.current) {
          clearInterval(melodicPatternRef.current);
        }
        
        // Create a gain node for melodic elements
        const melodyGain = context.createGain();
        melodyGain.gain.value = settings.melodyVolume;
        melodyGain.connect(masterGain);
        
        // Get scale for current mood
        const scale = musicalScales[settings.scale] || musicalScales.pentatonic;
        
        // Calculate tempo-related timing
        const tempo = settings.tempo;
        const beatDuration = 60 / tempo;
        
        // Determine note density based on mood
        let noteDensity, patternVariation;
        
        switch (mood) {
          case 'calm':
            noteDensity = 2 * beatDuration; // Every half note
            patternVariation = 0.3; // 30% timing variation
            break;
          case 'soft':
            noteDensity = 1.5 * beatDuration; // Dotted quarter notes
            patternVariation = 0.25;
            break;
          case 'uplifting':
            noteDensity = 0.5 * beatDuration; // Eighth notes
            patternVariation = 0.15;
            break;
          case 'warm':
            noteDensity = beatDuration; // Quarter notes
            patternVariation = 0.2;
            break;
          case 'cosmic':
            noteDensity = 3 * beatDuration; // Dotted half notes
            patternVariation = 0.4; // More varied
            break;
          default:
            noteDensity = beatDuration;
            patternVariation = 0.2;
        }
        
        // Convert to milliseconds
        const noteInterval = noteDensity * 1000;
        const intervalVariation = noteInterval * patternVariation;
        
        // Function to play a single melodic note
        const playMelodicNote = () => {
          // Choose note from scale
          const scaleIndex = Math.floor(Math.random() * scale.length);
          const semitones = scale[scaleIndex];
          
          // Adjust octave based on position in scale
          const octaveAdjust = Math.floor(scaleIndex / 7);
          
          // Calculate frequency from base frequency and semitones
          const frequency = settings.baseFreq * Math.pow(2, (semitones + 12 * octaveAdjust) / 12);
          
          // Create multi-oscillator for richer tone
          const createOscillatorGroup = () => {
            // Main oscillator
            const osc = context.createOscillator();
            
            // Choose waveform based on mood
            const waveforms = {
              calm: ['sine', 'triangle'],
              soft: ['sine', 'triangle'],
              uplifting: ['triangle', 'square'],
              warm: ['triangle', 'sine'],
              cosmic: ['sine', 'triangle']
            };
            
            const moodWaveforms = waveforms[mood] || ['sine', 'triangle'];
            osc.type = moodWaveforms[Math.floor(Math.random() * moodWaveforms.length)];
            
            osc.frequency.value = frequency;
            
            // Slight random detune for more organic sound
            osc.detune.value = Math.random() * 10 - 5;
            
            // Secondary oscillator for harmonic richness
            const osc2 = context.createOscillator();
            osc2.type = 'sine';
            
            // Fifth above (perfect fifth, 7 semitones)
            osc2.frequency.value = frequency * 1.5;
            osc2.detune.value = Math.random() * 10 - 5;
            
            // Gain nodes for each oscillator
            const oscGain = context.createGain();
            const osc2Gain = context.createGain();
            
            oscGain.gain.value = 0.7;
            osc2Gain.gain.value = 0.3;
            
            // Filter for tone shaping
            const filter = context.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = settings.filterFreq * 2;
            filter.Q.value = settings.filterQ * 0.8;
            
            // Create stereo panner for spatial position
            const panner = context.createStereoPanner();
            panner.pan.value = Math.random() * 0.8 - 0.4; // Random position between -0.4 and 0.4
            
            // Connect everything
            osc.connect(oscGain);
            osc2.connect(osc2Gain);
            
            oscGain.connect(filter);
            osc2Gain.connect(filter);
            
            filter.connect(panner);
            panner.connect(melodyGain);
            
            return {
              oscillators: [osc, osc2],
              gains: [oscGain, osc2Gain],
              filter,
              panner
            };
          };
          
          // Create oscillator group
          const oscGroup = createOscillatorGroup();
          
          // Note duration based on mood - normally a percentage of the interval
          const durationFactor = {
            calm: 0.9, // Long, legato notes
            soft: 0.8,
            uplifting: 0.6, // Shorter, more staccato
            warm: 0.75,
            cosmic: 0.95 // Very long, connected notes
          };
          
          const noteDuration = noteDensity * (durationFactor[mood] || 0.7);
          
          // Attack and release times scaled to note duration
          const attackTime = Math.min(noteDuration * 0.3, settings.attackTime);
          const releaseTime = Math.min(noteDuration * 0.5, settings.releaseTime);
          
          // Apply envelopes to all oscillator gains
          oscGroup.gains.forEach(gain => {
            // Attack
            gain.gain.setValueAtTime(0, context.currentTime);
            gain.gain.linearRampToValueAtTime(
              gain.gain.value,
              context.currentTime + attackTime
            );
            
            // Release
            gain.gain.setValueAtTime(
              gain.gain.value,
              context.currentTime + noteDuration - releaseTime
            );
            gain.gain.linearRampToValueAtTime(
              0,
              context.currentTime + noteDuration
            );
          });
          
          // Filter envelope for dynamic tone
          oscGroup.filter.frequency.setValueAtTime(
            settings.filterFreq * 2,
            context.currentTime
          );
          oscGroup.filter.frequency.linearRampToValueAtTime(
            settings.filterFreq,
            context.currentTime + noteDuration
          );
          
          // Start and stop oscillators
          oscGroup.oscillators.forEach(osc => {
            osc.start(context.currentTime);
            osc.stop(context.currentTime + noteDuration + 0.1);
            
            // Store for cleanup
            oscillatorsRef.current.push(osc);
          });
          
          // Schedule next note with variation
          const nextNoteTime = noteInterval + (Math.random() * intervalVariation * 2 - intervalVariation);
          
          if (melodicPatternRef.current) {
            clearTimeout(melodicPatternRef.current);
          }
          
          melodicPatternRef.current = setTimeout(() => {
            if (isPlaying) {
              playMelodicNote();
            }
          }, nextNoteTime);
        };
        
        // Start playing notes
        playMelodicNote();
      };
      
      // Create subtle percussion pattern
      const createPercussionPattern = (settings) => {
        const context = audioContextRef.current;
        const masterGain = masterGainRef.current;
        
        if (!context || !masterGain) return;
        
        // Clear any existing pattern
        if (percussionPatternRef.current) {
          clearInterval(percussionPatternRef.current);
        }
        
        // Create a gain node for percussion
        const percussionGain = context.createGain();
        percussionGain.gain.value = 0.2; // Lower volume for percussion
        percussionGain.connect(masterGain);
        
        // Calculate tempo-related timing
        const tempo = settings.tempo;
        const beatDuration = 60 / tempo;
        
        // Create percussion sounds
        const createHiHat = () => {
          // White noise buffer for hi-hat
          const bufferSize = context.sampleRate * 0.1; // 100ms buffer
          const noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
          const output = noiseBuffer.getChannelData(0);
          
          // Fill buffer with white noise
          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }
          
          // Create source from buffer
          const source = context.createBufferSource();
          source.buffer = noiseBuffer;
          
          // Create bandpass filter for hi-hat sound
          const filter = context.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = 8000;
          filter.Q.value = 1;
          
          // Create envelope with gain node
          const gainNode = context.createGain();
          gainNode.gain.value = 0;
          
          // Create panner for stereo image
          const panner = context.createStereoPanner();
          panner.pan.value = 0.3; // Slightly to the right
          
          // Connect nodes: Source -> Filter -> Gain -> Panner -> Percussion Gain
          source.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(panner);
          panner.connect(percussionGain);
          
          // Very short envelope for hi-hat
          const duration = 0.05 + Math.random() * 0.05; // 50-100ms
          
          gainNode.gain.setValueAtTime(0, context.currentTime);
          gainNode.gain.linearRampToValueAtTime(0.5, context.currentTime + 0.001); // Fast attack
          gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration); // Quick decay
          
          // Start and stop source
          source.start(context.currentTime);
          source.stop(context.currentTime + duration + 0.01);
          
          // Store for cleanup
          ambientSourcesRef.current.push(source);
        };
        
        const createKick = () => {
          // Create oscillator for kick sound
          const osc = context.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = 150; // Start frequency
          
          // Create envelope with gain node
          const gainNode = context.createGain();
          gainNode.gain.value = 0;
          
          // Create panner for stereo image
          const panner = context.createStereoPanner();
          panner.pan.value = -0.2; // Slightly to the left
          
          // Connect nodes
          osc.connect(gainNode);
          gainNode.connect(panner);
          panner.connect(percussionGain);
          
          // Duration for kick
          const duration = 0.15;
          
          // Frequency envelope for pitch drop
          osc.frequency.setValueAtTime(150, context.currentTime);
          osc.frequency.exponentialRampToValueAtTime(55, context.currentTime + 0.08);
          
          // Amplitude envelope
          gainNode.gain.setValueAtTime(0, context.currentTime);
          gainNode.gain.linearRampToValueAtTime(0.7, context.currentTime + 0.01); // Fast attack
          gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration); // Decay
          
          // Start and stop oscillator
          osc.start(context.currentTime);
          osc.stop(context.currentTime + duration + 0.01);
          
          // Store for cleanup
          oscillatorsRef.current.push(osc);
        };
        
        const createSnare = () => {
          // Combine noise and oscillator for snare
          
          // 1. Noise component (for the snare "rattle")
          const bufferSize = context.sampleRate * 0.2; // 200ms buffer
          const noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);
          const output = noiseBuffer.getChannelData(0);
          
          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }
          
          const noiseSource = context.createBufferSource();
          noiseSource.buffer = noiseBuffer;
          
          // Filter for noise
          const noiseFilter = context.createBiquadFilter();
          noiseFilter.type = 'highpass';
          noiseFilter.frequency.value = 1000;
          
          // Gain for noise
          const noiseGain = context.createGain();
          noiseGain.gain.value = 0;
          
          // Connect noise path
          noiseSource.connect(noiseFilter);
          noiseFilter.connect(noiseGain);
          
          // 2. Tonal component (for the snare "body")
          const osc = context.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = 180;
          
          const oscGain = context.createGain();
          oscGain.gain.value = 0;
          
          // Connect oscillator path
          osc.connect(oscGain);
          
          // Create panner for stereo image
          const panner = context.createStereoPanner();
          panner.pan.value = 0;
          
          // Connect both paths to panner
          noiseGain.connect(panner);
          oscGain.connect(panner);
          
          // Connect to percussion gain
          panner.connect(percussionGain);
          
          // Duration
          const duration = 0.2;
          
          // Envelopes
          // Noise envelope (longer)
          noiseGain.gain.setValueAtTime(0, context.currentTime);
          noiseGain.gain.linearRampToValueAtTime(0.5, context.currentTime + 0.005);
          noiseGain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration);
          
          // Oscillator envelope (shorter)
          oscGain.gain.setValueAtTime(0, context.currentTime);
          oscGain.gain.linearRampToValueAtTime(0.3, context.currentTime + 0.005);
          oscGain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.1);
          
          // Start and stop
          noiseSource.start(context.currentTime);
          osc.start(context.currentTime);
          
          noiseSource.stop(context.currentTime + duration + 0.01);
          osc.stop(context.currentTime + duration + 0.01);
          
          // Store for cleanup
          ambientSourcesRef.current.push(noiseSource);
          oscillatorsRef.current.push(osc);
        };
        
        // Create percussion pattern based on mood
        let pattern = [];
        let currentBeat = 0;
        
        switch (mood) {
          case 'uplifting':
            // More energetic pattern with kick on 1 and 3, snare on 2 and 4
            pattern = [
              { beat: 0, instruments: ['kick'] },
              { beat: 0.5, instruments: ['hihat'] },
              { beat: 1, instruments: ['snare'] },
              { beat: 1.5, instruments: ['hihat'] },
              { beat: 2, instruments: ['kick'] },
              { beat: 2.5, instruments: ['hihat'] },
              { beat: 3, instruments: ['snare'] },
              { beat: 3.5, instruments: ['hihat'] }
            ];
            break;
            
          case 'warm':
            // Gentle but rhythmic pattern
            pattern = [
              { beat: 0, instruments: ['kick'] },
              { beat: 1, instruments: ['snare'] },
              { beat: 1.75, instruments: ['hihat'] },
              { beat: 2, instruments: ['kick'] },
              { beat: 3, instruments: ['snare'] },
              { beat: 3.5, instruments: ['hihat'] }
            ];
            break;
            
          case 'soft':
            // Very subtle pattern, mainly hi-hats
            pattern = [
              { beat: 0, instruments: ['kick'] },
              { beat: 1, instruments: ['hihat'] },
              { beat: 2, instruments: ['hihat'] },
              { beat: 3, instruments: ['hihat'] }
            ];
            break;
            
          default:
            // Default simple pattern
            pattern = [
              { beat: 0, instruments: ['kick'] },
              { beat: 1, instruments: ['hihat'] },
              { beat: 2, instruments: ['snare'] },
              { beat: 3, instruments: ['hihat'] }
            ];
        }
        
        // Find pattern length in beats
        const patternLength = Math.max(...pattern.map(p => p.beat)) + 1;
        
        // Schedule initial pattern playback
        const schedulePattern = () => {
          // Find events at current beat
          const events = pattern.filter(p => Math.abs(p.beat - currentBeat) < 0.01);
          
          // Play each instrument for matching events
          events.forEach(event => {
            event.instruments.forEach(instrument => {
              if (instrument === 'kick') createKick();
              else if (instrument === 'snare') createSnare();
              else if (instrument === 'hihat') createHiHat();
            });
          });
          
          // Advance beat position
          currentBeat = (currentBeat + 0.5) % patternLength;
          
          // Schedule next beat
          percussionPatternRef.current = setTimeout(() => {
            if (isPlaying) {
              schedulePattern();
            }
          }, beatDuration * 500); // 8th notes (half a beat)
        };
        
        // Start pattern
        schedulePattern();
      };
      
      return null; // Audio component doesn't render anything
    });

    // Enhanced Visual Canvas Component
    const moodSettings = {
      calm: {
        colors: ['#1a5276', '#2980b9', '#3498db', '#85c1e9', '#d6eaf8'],
        fogColor: '#1a3c5e',
        fogDensity: 0.015,
        speed: 0.5,
        complexity: 0.4,
        bloom: 0.5,
        particleCount: 1500,
        cameraDistance: 20
      },
      soft: {
        colors: ['#f7dc6f', '#f8c471', '#f39c12', '#e67e22', '#f5b7b1'],
        fogColor: '#59453c',
        fogDensity: 0.01,
        speed: 0.6,
        complexity: 0.6,
        bloom: 0.7,
        particleCount: 2000,
        cameraDistance: 18
      },
      uplifting: {
        colors: ['#58d68d', '#2ecc71', '#138d75', '#1abc9c', '#abebc6'],
        fogColor: '#2a6350',
        fogDensity: 0.005,
        speed: 0.8,
        complexity: 0.7,
        bloom: 0.8,
        particleCount: 3000,
        cameraDistance: 16
      },
      warm: {
        colors: ['#e74c3c', '#ec7063', '#f1948a', '#f5b7b1', '#fadbd8'],
        fogColor: '#4a2e2c',
        fogDensity: 0.012,
        speed: 0.6,
        complexity: 0.5,
        bloom: 0.6,
        particleCount: 2500,
        cameraDistance: 17
      },
      cosmic: {
        colors: ['#6c3483', '#8e44ad', '#9b59b6', '#bb8fce', '#d2b4de'],
        fogColor: '#281435',
        fogDensity: 0.02,
        speed: 0.7,
        complexity: 0.9,
        bloom: 1.0,
        particleCount: 4000,
        cameraDistance: 25
      }
    };

    const VisualCanvas = React.forwardRef(({ isPlaying, mood, audioData }, ref) => {
      const canvasRef = React.useRef(null);
      const sceneRef = React.useRef(null);
      const cameraRef = React.useRef(null);
      const rendererRef = React.useRef(null);
      const composerRef = React.useRef(null);
      const controlsRef = React.useRef(null);
      const timeRef = React.useRef(0);
      const frameIdRef = React.useRef(null);
      const objectsRef = React.useRef([]);
      const particlesRef = React.useRef(null);
      const cloudsRef = React.useRef(null);
      const lightningRef = React.useRef({
        active: false,
        intensity: 0,
        nextStrike: 0
      });
      
      // Audio reactivity
      const audioReactivityRef = React.useRef({
        bassPower: 0,
        midPower: 0,
        treblePower: 0,
        overallPower: 0,
        bassImpact: 0,
        peakDetector: { threshold: 0.5, lastPeak: 0, cooldown: 20 }
      });
      
      // Expose canvas and other renderer elements to parent
      React.useImperativeHandle(ref, () => ({
        canvas: canvasRef.current,
        renderer: rendererRef.current,
        getSceneData: () => ({
          scene: sceneRef.current,
          camera: cameraRef.current
        })
      }));
      
      // Process audio data for visualization
      const processAudioData = (data) => {
        if (!data) return;
        
        const audioReactivity = audioReactivityRef.current;
        
        // Calculate frequency band power
        const bassSum = data.slice(1, 10).reduce((sum, val) => sum + val, 0);
        const midSum = data.slice(10, 100).reduce((sum, val) => sum + val, 0);
        const trebleSum = data.slice(100, 300).reduce((sum, val) => sum + val, 0);
        
        // Normalize
        const bassNorm = bassSum / 10 / 255;
        const midNorm = midSum / 90 / 255;
        const trebleNorm = trebleSum / 200 / 255;
        
        // Smooth values
        const smoothingFactor = 0.1;
        audioReactivity.bassPower = audioReactivity.bassPower * (1 - smoothingFactor) + bassNorm * smoothingFactor;
        audioReactivity.midPower = audioReactivity.midPower * (1 - smoothingFactor) + midNorm * smoothingFactor;
        audioReactivity.treblePower = audioReactivity.treblePower * (1 - smoothingFactor) + trebleNorm * smoothingFactor;
        
        // Overall power
        audioReactivity.overallPower = (audioReactivity.bassPower + audioReactivity.midPower + audioReactivity.treblePower) / 3;
        
        // Detect bass impacts (for camera shake, etc.)
        const bassImpactSmoothingFactor = 0.3;
        const previousBassPower = audioReactivity.bassImpact;
        audioReactivity.bassImpact = audioReactivity.bassImpact * (1 - bassImpactSmoothingFactor) + 
                                    (Math.max(0, bassNorm - previousBassPower)) * bassImpactSmoothingFactor * 5;
        
        // Peak detection for events (like lightning)
        const peakDetector = audioReactivity.peakDetector;
        peakDetector.lastPeak++;
        
        if (audioReactivity.bassPower > peakDetector.threshold && peakDetector.lastPeak > peakDetector.cooldown) {
          peakDetector.lastPeak = 0;
          return true; // Peak detected
        }
        
        return false;
      };
      
      // Initialize Three.js scene
      React.useEffect(() => {
        const canvas = canvasRef.current;
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Create scene
        const scene = new THREE.Scene();
        sceneRef.current = scene;
        scene.background = new THREE.Color('#000000');
        
        // Add fog
        scene.fog = new THREE.FogExp2(moodSettings[mood].fogColor, moodSettings[mood].fogDensity);
        
        // Create camera
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        cameraRef.current = camera;
        camera.position.set(0, 5, moodSettings[mood].cameraDistance);
        camera.lookAt(0, 0, 0);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ 
          canvas, 
          antialias: true,
          preserveDrawingBuffer: true,  // Needed for video recording
          powerPreference: "high-performance",
          alpha: true
        });
        rendererRef.current = renderer;
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        
        // Create orbit controls for camera
        const controls = new THREE.OrbitControls(camera, canvas);
        controlsRef.current = controls;
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.enableZoom = false; // Disable zoom for smoother experience
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.1 * moodSettings[mood].speed;
        
        // Create post-processing passes
        // 1. Render pass
        const renderPass = new THREE.RenderPass(scene, camera);
        
        // 2. Bloom pass
        const bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(width, height),
          1.5,  // strength
          0.4,  // radius
          0.85  // threshold
        );
        bloomPass.strength = moodSettings[mood].bloom * 1.5;
        
        // 3. FXAA pass for anti-aliasing
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.set(1 / width, 1 / height);
        
        // Create composer and add passes
        const composer = new THREE.EffectComposer(renderer);
        composerRef.current = composer;
        
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(fxaaPass);
        
        // Resize handler
        const handleResize = () => {
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          renderer.setSize(width, height);
          composer.setSize(width, height);
          
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          
          fxaaPass.material.uniforms['resolution'].value.set(1 / width, 1 / height);
        };
        
        window.addEventListener('resize', handleResize);
        
        // Initial scene creation
        createScene(mood);
        
        return () => {
          window.removeEventListener('resize', handleResize);
          if (frameIdRef.current) {
            cancelAnimationFrame(frameIdRef.current);
          }
          
          // Dispose controls
          if (controlsRef.current) {
            controlsRef.current.dispose();
          }
          
          // Clean up Three.js resources
          scene.traverse(object => {
            if (object.isMesh) {
              object.geometry.dispose();
              if (object.material.isMaterial) {
                cleanupMaterial(object.material);
              } else {
                for (const material of object.material) {
                  cleanupMaterial(material);
                }
              }
            }
          });
          
          renderer.dispose();
          composer.dispose();
        };
      }, []);
      
      // Change scene based on mood
      React.useEffect(() => {
        if (sceneRef.current) {
          // Update fog
          sceneRef.current.fog.color.set(moodSettings[mood].fogColor);
          sceneRef.current.fog.density = moodSettings[mood].fogDensity;
          
          // Update bloom
          if (composerRef.current && composerRef.current.passes[1]) {
            composerRef.current.passes[1].strength = moodSettings[mood].bloom * 1.5;
          }
          
          // Update orbit controls
          if (controlsRef.current) {
            controlsRef.current.autoRotateSpeed = 0.1 * moodSettings[mood].speed;
          }
          
          // Update camera position
          if (cameraRef.current) {
            cameraRef.current.position.z = moodSettings[mood].cameraDistance;
          }
          
          // Create new scene
          createScene(mood);
        }
      }, [mood]);
      
      // Animation loop
      React.useEffect(() => {
        if (isPlaying) {
          const animate = () => {
            timeRef.current += 0.01 * moodSettings[mood].speed;
            
            // Process audio data if available
            const bassImpact = audioData ? processAudioData(audioData()) : false;
            
            // Update scene elements
            updateScene(timeRef.current, mood, bassImpact);
            
            // Update controls
            if (controlsRef.current) {
              controlsRef.current.update();
            }
            
            // Render using composer
            composerRef.current.render();
            
            // Schedule next frame
            frameIdRef.current = requestAnimationFrame(animate);
          };
          
          frameIdRef.current = requestAnimationFrame(animate);
        } else if (frameIdRef.current) {
          cancelAnimationFrame(frameIdRef.current);
        }
        
        return () => {
          if (frameIdRef.current) {
            cancelAnimationFrame(frameIdRef.current);
          }
        };
      }, [isPlaying, mood, audioData]);
      
      // Clean up material
      const cleanupMaterial = (material) => {
        material.dispose();
        
        // Dispose textures
        for (const prop in material) {
          const value = material[prop];
          if (value && typeof value === 'object' && 'isTexture' in value) {
            value.dispose();
          }
        }
      };
      
      // Create scene based on mood
      const createScene = (mood) => {
        const scene = sceneRef.current;
        const settings = moodSettings[mood];
        
        // Clear previous objects
        objectsRef.current.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(m => cleanupMaterial(m));
            } else {
              cleanupMaterial(obj.material);
            }
          }
        });
        objectsRef.current = [];
        
        // Create new objects based on mood
        
        // 1. Add lighting
        createLighting(scene, settings);
        
        // 2. Background stars
        createStars(scene, settings);
        
        // 3. Create landscape
        createLandscape(scene, settings);
        
        // 4. Create water
        createWater(scene, settings);
        
        // 5. Create celestial objects
        createCelestialObjects(scene, settings);
        
        // 6. Create plants
        createPlants(scene, settings);
        
        // 7. Create particles (fireflies, mist, etc.)
        createParticles(scene, settings);
        
        // 8. Create clouds
        createClouds(scene, settings);
      };
      
      // Create lighting
      const createLighting = (scene, settings) => {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        objectsRef.current.push(ambientLight);
        
        // Main directional light (sun/moon)
        const mainLight = new THREE.DirectionalLight(
          new THREE.Color(settings.colors[1]).lerp(new THREE.Color(0xffffff), 0.5),
          1.0
        );
        mainLight.position.set(30, 30, 30);
        mainLight.castShadow = true;
        
        // Configure shadow
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 100;
        mainLight.shadow.camera.left = -30;
        mainLight.shadow.camera.right = 30;
        mainLight.shadow.camera.top = 30;
        mainLight.shadow.camera.bottom = -30;
        mainLight.shadow.bias = -0.0001;
        
        scene.add(mainLight);
        objectsRef.current.push(mainLight);
        
        // Secondary fill light
        const fillLight = new THREE.DirectionalLight(
          new THREE.Color(settings.colors[3]),
          0.5
        );
        fillLight.position.set(-20, 10, -20);
        scene.add(fillLight);
        objectsRef.current.push(fillLight);
        
        // Lightning light (initially off)
        const lightningLight = new THREE.PointLight(0xaaccff, 0, 100);
        lightningLight.position.set(
          Math.random() * 30 - 15,
          20,
          Math.random() * 30 - 15
        );
        lightningLight.userData = { type: 'lightning' };
        scene.add(lightningLight);
        objectsRef.current.push(lightningLight);
      };
      
      // Update scene animation
      const updateScene = (time, mood, bassImpact) => {
        const settings = moodSettings[mood];
        const audioReactivity = audioReactivityRef.current;
        
        // Update camera for bass impacts
        if (bassImpact && mood !== 'calm' && cameraRef.current) {
          // Apply slight camera shake based on bass
          const shakeAmount = audioReactivity.bassImpact * 0.2;
          cameraRef.current.position.y += Math.sin(time * 100) * shakeAmount;
          cameraRef.current.position.x += Math.cos(time * 95) * shakeAmount * 0.5;
        }
        
        // Process lightning effects
        const lightning = lightningRef.current;
        if (lightning.active) {
          // Update lightning
          lightning.intensity *= 0.9; // Fade out
          
          // Find lightning light and update
          const lightningLight = objectsRef.current.find(obj => 
            obj.isPointLight && obj.userData.type === 'lightning');
          
          if (lightningLight) {
            lightningLight.intensity = lightning.intensity * 2;
          }
          
          if (lightning.intensity < 0.05) {
            lightning.active = false;
          }
        } else {
          // Randomly trigger lightning in cosmic mood
          if (mood === 'cosmic' && Math.random() < 0.001) {
            // Start lightning
            lightning.active = true;
            lightning.intensity = 1.0;
            
            // Move lightning to random position
            const lightningLight = objectsRef.current.find(obj => 
              obj.isPointLight && obj.userData.type === 'lightning');
            
            if (lightningLight) {
              lightningLight.position.set(
                Math.random() * 50 - 25,
                10 + Math.random() * 20,
                Math.random() * 50 - 25
              );
            }
          }
        }
        
        // Update all objects based on their type
        objectsRef.current.forEach(obj => {
          if (!obj.userData) return;
          
          switch (obj.userData.type) {
            case 'star':
              // Slow rotation for star field
              obj.rotation.y = time * 0.05;
              obj.rotation.z = time * 0.02;
              
              // Pulsate based on treble
              if (audioReactivity && obj.material) {
                obj.material.size = 0.1 + audioReactivity.treblePower * 0.1;
              }
              break;
              
            case 'plant':
              // Swaying motion for plants
              obj.rotation.y = Math.sin(time * 0.2 + obj.userData.offset) * 0.1;
              obj.position.y = obj.userData.originalY + 
                              Math.sin(time * 0.3 + obj.userData.offset) * 0.1;
                              
              // React to mid frequencies
              if (audioReactivity) {
                const scaleFactor = 1 + audioReactivity.midPower * 0.2;
                obj.scale.set(scaleFactor, scaleFactor, scaleFactor);
              }
              break;
              
            case 'water':
              // Update water shader time
              if (obj.material && obj.material.uniforms) {
                obj.material.uniforms.time.value = time;
                
                // Audio reactivity for water
                if (audioReactivity) {
                  obj.material.uniforms.waveHeight.value = 
                    1.0 + audioReactivity.bassPower * 2.0;
                }
              }
              break;
              
            case 'celestial':
              // Orbit motion for celestial objects
              obj.position.x = obj.userData.radius * Math.cos(time * obj.userData.speed);
              obj.position.z = obj.userData.radius * Math.sin(time * obj.userData.speed);
              obj.rotation.y = time * 0.5;
              
              // Audio reactive glow (if the object has children)
              if (audioReactivity && obj.children.length > 0) {
                const glowMesh = obj.children[0];
                if (glowMesh && glowMesh.material) {
                  glowMesh.material.opacity = 0.3 + audioReactivity.midPower * 0.7;
                  glowMesh.scale.set(
                    1.2 + audioReactivity.midPower * 0.4,
                    1.2 + audioReactivity.midPower * 0.4,
                    1.2 + audioReactivity.midPower * 0.4
                  );
                }
              }
              break;
              
            case 'terrain':
              // Update terrain shader time
              if (obj.material && obj.material.uniforms) {
                obj.material.uniforms.time.value = time;
                
                // Audio reactivity for terrain
                if (audioReactivity) {
                  obj.material.uniforms.elevationScale.value = 
                    1.0 + audioReactivity.bassPower * 0.5;
                }
              }
              break;
              
            case 'cloud':
              // Drift clouds slowly
              obj.position.x += Math.sin(time * 0.1 + obj.userData.offset) * 0.01;
              obj.position.z += Math.cos(time * 0.1 + obj.userData.offset) * 0.01;
              
              // Slowly rotate
              obj.rotation.y = time * 0.05 + obj.userData.offset;
              
              // Audio reactivity for clouds
              if (audioReactivity && obj.material) {
                // Pulse opacity with low frequencies
                obj.material.opacity = 
                  obj.userData.baseOpacity * (1 + audioReactivity.bassPower * 0.5);
              }
              break;
              
            case 'particles':
              // Update particle system
              if (obj.material && obj.material.uniforms) {
                obj.material.uniforms.time.value = time;
                
                // Audio reactivity for particles
                if (audioReactivity) {
                  obj.material.uniforms.audioStrength.value = 
                    audioReactivity.overallPower * 2.0;
                }
              }
              break;
          }
        });
      };
      
      // Create stars
      const createStars = (scene, settings) => {
        // Small distant stars
        const starCount = 2000 + Math.floor(settings.complexity * 3000);
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.1,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true
        });
        
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        const sizes = new Float32Array(starCount);
        
        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          
          // Position stars in a large sphere
          const radius = 50 + Math.random() * 50;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);
          
          // Give stars slightly different colors
          const starColor = new THREE.Color();
          
          // Temperature-based color
          if (Math.random() > 0.8) {
            // Reddish star
            starColor.setHSL(0.05, 1.0, 0.7);
          } else if (Math.random() > 0.6) {
            // Yellowish star
            starColor.setHSL(0.12, 1.0, 0.8);
          } else {
            // White-blue star
            starColor.setHSL(0.6, Math.random() * 0.3, 0.9);
          }
          
          colors[i3] = starColor.r;
          colors[i3 + 1] = starColor.g;
          colors[i3 + 2] = starColor.b;
          
          // Different star sizes
          sizes[i] = Math.random() * 0.1 + 0.05;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const stars = new THREE.Points(starGeometry, starMaterial);
        stars.userData = { type: 'star' };
        scene.add(stars);
        objectsRef.current.push(stars);
        
        // Add a few glowing nebulae
        const nebulaCount = Math.floor(settings.complexity * 7);
        
        for (let i = 0; i < nebulaCount; i++) {
          const colorIndex = Math.floor(Math.random() * settings.colors.length);
          const color = new THREE.Color(settings.colors[colorIndex]);
          
          // Create a larger, more complex nebula shape
          const nebulaGeometry = new THREE.SphereGeometry(
            1 + Math.random() * 4,
            8,
            8
          );
          
          // Distort the geometry for more natural shape
          const positionAttribute = nebulaGeometry.getAttribute('position');
          const vertex = new THREE.Vector3();
          
          for (let v = 0; v < positionAttribute.count; v++) {
            vertex.fromBufferAttribute(positionAttribute, v);
            
            // Apply noise-based displacement
            const noise = Math.sin(vertex.x * 2) * Math.sin(vertex.y * 3) * Math.sin(vertex.z * 2);
            vertex.multiplyScalar(1 + noise * 0.4);
            
            positionAttribute.setXYZ(v, vertex.x, vertex.y, vertex.z);
          }
          
          const nebulaMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
          });
          
          const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
          
          // Position in 3D space
          nebula.position.set(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
          );
          
          // Random scale and rotation
          nebula.scale.set(
            3 + Math.random() * 5,
            3 + Math.random() * 5,
            6 + Math.random() * 15
          );
          
          nebula.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          );
          
          nebula.userData = { type: 'nebula' };
          scene.add(nebula);
          objectsRef.current.push(nebula);
        }
      };
      
      // Create improved landscape/terrain
      const createLandscape = (scene, settings) => {
        const terrainSize = 100;
        const segments = 256; // Higher detail
        
        const terrainGeometry = new THREE.PlaneGeometry(
          terrainSize,
          terrainSize,
          segments,
          segments
        );
        
        // Convert colors to THREE.Color objects
        const colors = settings.colors.map(color => new THREE.Color(color));
        
        // Create custom terrain shader with improved features
        const terrainMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            baseColors: { value: colors },
            complexity: { value: settings.complexity },
            elevationScale: { value: 1.0 }
          },
          vertexShader: `
            uniform float time;
            uniform float complexity;
            uniform float elevationScale;
            
            varying vec2 vUv;
            varying float vElevation;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            // Simplex noise functions from https://github.com/ashima/webgl-noise
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            
            float snoise(vec2 v) {
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                 -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy));
              vec2 x0 = v -   i + dot(i, C.xx);
              vec2 i1;
              i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod289(i);
              vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
              vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),
                                    dot(x12.zw, x12.zw)), 0.0);
              m = m*m;
              m = m*m;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
              vec3 g;
              g.x  = a0.x  * x0.x  + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
            }
            
            // Ridged multifractal terrain
            float ridgedMF(vec2 position) {
              float lacunarity = 2.0;
              float gain = 0.5;
              float offset = 0.9;
              
              float sum = 0.0;
              float freq = 0.1;
              float amp = 0.5;
              float prev = 1.0;
              
              for(int i = 0; i < 5; i++) {
                float n = abs(snoise(position * freq + time * 0.05));
                n = n * n;
                n = offset - n;
                n = n * n * prev;
                prev = n;
                sum += n * amp;
                freq *= lacunarity;
                amp *= gain;
              }
              
              return sum;
            }
            
            float calculateElevation(vec2 position) {
              float scale1 = 0.1;
              float scale2 = 1.0;
              float scale3 = 2.0;
              float scale4 = 4.0;
              
              // Base continent shape (large, gentle undulations)
              float continent = snoise(position * 0.02 + time * 0.01) * 0.5 + 0.5;
              continent = pow(continent, 1.5); // Make flatter areas
              
              // Hills and mountains
              float hills = ridgedMF(position * scale1) * 0.3;
              
              // Medium details
              float mediumDetails = 0.0;
              if (complexity > 0.3) {
                  mediumDetails = ridgedMF(position * scale2) * 0.15;
              }
              
              // Fine details for higher complexity
              float fineDetails = 0.0;
              if (complexity > 0.6) {
                  fineDetails = snoise(position * scale3 + time * 0.03) * 0.1;
              }
              
              // Very fine details for highest complexity
              float microDetails = 0.0;
              if (complexity > 0.8) {
                  microDetails = snoise(position * scale4 + time * 0.04) * 0.05;
              }
              
              return (continent * hills + mediumDetails + fineDetails + microDetails) * elevationScale;
            }
            
            void main() {
              vUv = uv;
              vPosition = position;
              
              vec3 transformed = position;
              
              if (transformed.y > -48.0) { // Don't elevate edges of the plane
                float elevation = calculateElevation(transformed.xz);
                transformed.y += elevation * 10.0;
                vElevation = elevation;
                
                // Calculate normal for better lighting
                float delta = 0.1;
                float elevationX = calculateElevation(transformed.xz + vec2(delta, 0.0)) * 10.0;
                float elevationZ = calculateElevation(transformed.xz + vec2(0.0, delta)) * 10.0;
                
                vec3 tangentX = normalize(vec3(delta, elevationX - elevation * 10.0, 0.0));
                vec3 tangentZ = normalize(vec3(0.0, elevationZ - elevation * 10.0, delta));
                
                vNormal = normalize(cross(tangentZ, tangentX));
              } else {
                vElevation = -1.0;
                vNormal = normal;
              }
              
              gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 baseColors[5];
            uniform float complexity;
            
            varying vec2 vUv;
            varying float vElevation;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            // Simple smooth noise for texture variation
            float hash(vec2 p) {
              return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            float noise(vec2 p) {
              vec2 i = floor(p);
              vec2 f = fract(p);
              f = f * f * (3.0 - 2.0 * f); // Smooth interpolation
              
              float n = mix(
                mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
                f.y
              );
              
              return n;
            }
            
            void main() {
              if (vElevation < -0.9) {
                discard; // Don't render the edges
              }
              
              // Normalize elevation to 0-1 range for color mapping
              float normalizedElevation = (vElevation + 1.0) * 0.5;
              
              // Slope calculation for different textures on steep vs flat areas
              float slope = 1.0 - vNormal.y; // 0 for flat, 1 for vertical
              
              // Determine which color bands to interpolate between
              float adjustedElev = normalizedElevation * float(5); // 5 colors
              int baseIndex = int(floor(adjustedElev));
              int nextIndex = min(baseIndex + 1, 4);
              float mixAmount = fract(adjustedElev);
              
              // Mix between appropriate colors
              vec3 terrainColor = mix(
                baseColors[baseIndex],
                baseColors[nextIndex],
                mixAmount
              );
              
              // Add noise-based detail
              float detailNoise = noise(vPosition.xz * 0.2) * 0.05 +
                                noise(vPosition.xz * 1.0) * 0.025 +
                                noise(vPosition.xz * 5.0) * 0.0125;
              
              // Make steep areas more rocky
              float rockiness = smoothstep(0.3, 0.7, slope);
              float rockDetail = noise(vPosition.xz * 10.0) * 0.1 * rockiness;
              
              // Apply detail
              terrainColor = mix(terrainColor, terrainColor * (1.0 + detailNoise + rockDetail), 0.5);
              
              // Lighten peaks, darken valleys
              float heightEffect = smoothstep(0.0, 1.0, normalizedElevation) * 0.2;
              terrainColor = mix(terrainColor * 0.8, terrainColor * 1.2, heightEffect);
              
              // Apply basic lighting using normal
              float lightIntensity = max(0.3, dot(vNormal, normalize(vec3(0.5, 1.0, 0.5))));
              terrainColor *= lightIntensity;
              
              gl_FragColor = vec4(terrainColor, 1.0);
            }
          `,
          side: THREE.DoubleSide
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -8;
        terrain.receiveShadow = true;
        terrain.userData = { type: 'terrain' };
        
        scene.add(terrain);
        objectsRef.current.push(terrain);
      };
      
      // Create improved water
      const createWater = (scene, settings) => {
        const waterSize = 90;
        const segments = 256;
        
        const waterGeometry = new THREE.PlaneGeometry(
          waterSize,
          waterSize,
          segments,
          segments
        );
        
        // Get colors from settings
        const colors = settings.colors.map(color => new THREE.Color(color));
        
        // Create enhanced water shader
        const waterMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            waterColors: { value: [
              new THREE.Color(settings.colors[0]),
              new THREE.Color(settings.colors[3])
            ]},
            waveHeight: { value: 1.0 },
            baseWaterColor: { value: new THREE.Color(settings.colors[0]).lerp(new THREE.Color(0x101010), 0.7) }
          },
          vertexShader: `
            uniform float time;
            uniform float waveHeight;
            
            varying vec2 vUv;
            varying float vWaveHeight;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            // Simplex noise functions
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            
            float snoise(vec2 v) {
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                 -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy));
              vec2 x0 = v -   i + dot(i, C.xx);
              vec2 i1;
              i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod289(i);
              vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
              vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),
                                    dot(x12.zw, x12.zw)), 0.0);
              m = m*m;
              m = m*m;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
              vec3 g;
              g.x  = a0.x  * x0.x  + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
            }
            
            void main() {
              vUv = uv;
              vPosition = position;
              
              vec3 transformed = position;
              
              // Distance from center for edge dampening
              float distFromCenter = length(transformed.xz) / (${waterSize.toFixed(1)} * 0.5);
              float edgeFactor = 1.0 - smoothstep(0.7, 0.95, distFromCenter);
              
              // Calculate multiple layers of waves with different frequencies
              float wave1 = snoise(vec2(transformed.x * 0.05 + time * 0.2, 
                            transformed.z * 0.05 + time * 0.1)) * 0.5;
              
              float wave2 = snoise(vec2(transformed.x * 0.1 - time * 0.15, 
                            transformed.z * 0.1)) * 0.25;
              
              float wave3 = snoise(vec2(transformed.x * 0.2 + time * 0.1, 
                            transformed.z * 0.2 - time * 0.05)) * 0.125;
              
              // Smaller, higher-frequency waves for detail
              float wave4 = snoise(vec2(transformed.x * 0.4 - time * 0.3, 
                            transformed.z * 0.4 + time * 0.2)) * 0.0625;
              
              // Combine waves and apply edge dampening
              float waveHeight = (wave1 + wave2 + wave3 + wave4) * edgeFactor * waveHeight;
              transformed.y += waveHeight;
              
              vWaveHeight = waveHeight;
              
              // Calculate normal for better reflections and lighting
              float delta = 0.1;
              float heightX1 = snoise(vec2(transformed.x * 0.05 + delta + time * 0.2, 
                             transformed.z * 0.05 + time * 0.1)) * 0.5 +
                             snoise(vec2(transformed.x * 0.1 + delta - time * 0.15, 
                             transformed.z * 0.1)) * 0.25;
                            
              float heightX2 = snoise(vec2(transformed.x * 0.05 - delta + time * 0.2, 
                             transformed.z * 0.05 + time * 0.1)) * 0.5 +
                             snoise(vec2(transformed.x * 0.1 - delta - time * 0.15, 
                             transformed.z * 0.1)) * 0.25;
                            
              float heightZ1 = snoise(vec2(transformed.x * 0.05 + time * 0.2, 
                             transformed.z * 0.05 + delta + time * 0.1)) * 0.5 +
                             snoise(vec2(transformed.x * 0.1 - time * 0.15, 
                             transformed.z * 0.1 + delta)) * 0.25;
                            
              float heightZ2 = snoise(vec2(transformed.x * 0.05 + time * 0.2, 
                             transformed.z * 0.05 - delta + time * 0.1)) * 0.5 +
                             snoise(vec2(transformed.x * 0.1 - time * 0.15, 
                             transformed.z * 0.1 - delta)) * 0.25;
              
              vec3 normalX = normalize(vec3(2.0 * delta, heightX1 - heightX2, 0.0));
              vec3 normalZ = normalize(vec3(0.0, heightZ1 - heightZ2, 2.0 * delta));
              
              vNormal = normalize(cross(normalZ, normalX));
              
              gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 waterColors[2];
            uniform vec3 baseWaterColor;
            
            varying vec2 vUv;
            varying float vWaveHeight;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
              // Map wave height to color mix
              float mixFactor = (vWaveHeight + 0.875) * 0.5; // Normalize to 0-1 range
              
              // Mix between the two water colors
              vec3 waterColor = mix(waterColors[0], waterColors[1], mixFactor);
              
              // Distance from center for edge effect
              float distFromCenter = length(vPosition.xz) / 45.0;
              float edgeFactor = smoothstep(0.8, 0.95, distFromCenter);
              
              // Mix with deeper water color near edges
              waterColor = mix(waterColor, baseWaterColor, edgeFactor);
              
              // Add reflections based on normal
              vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
              float fresnel = 0.1 + 0.9 * pow(1.0 - dot(normalize(vNormal), normalize(vec3(0.0, 1.0, 0.0))), 3.0);
              float specular = pow(max(0.0, dot(reflect(-lightDir, vNormal), vec3(0.0, 1.0, 0.0))), 20.0) * 0.8;
              
              // Apply lighting effects
              waterColor += vec3(specular);
              waterColor = mix(waterColor, waterColors[1], fresnel * 0.5);
              
              gl_FragColor = vec4(waterColor, 0.8); // Slightly transparent
            }
          `,
          transparent: true,
          side: THREE.DoubleSide
        });
        
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -7;
        water.userData = { type: 'water' };
        
        scene.add(water);
        objectsRef.current.push(water);
      };
      
      // Create enhanced celestial objects
      const createCelestialObjects = (scene, settings) => {
        // Create sun or moon
        const mainCelestialSize = 5;
        const mainCelestialGeometry = new THREE.SphereGeometry(mainCelestialSize, 64, 64);
        
        // Choose color based on mood
        const mainColor = new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]);
        
        // Create texture for celestial object
        const celestialCanvas = document.createElement('canvas');
        celestialCanvas.width = 1024;
        celestialCanvas.height = 1024;
        const context = celestialCanvas.getContext('2d');
        
        // Fill with base color
        context.fillStyle = `#${mainColor.getHexString()}`;
        context.fillRect(0, 0, 1024, 1024);
        
        // Add some texture details
        const isMoon = mood === 'calm' || mood === 'cosmic';
        
        if (isMoon) {
          // Create moon craters
          for (let i = 0; i < 100; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 5 + Math.random() * 50;
            const gradient = context.createRadialGradient(x, y, 0, x, y, radius);
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
          }
        } else {
          // Create sun surface details
          context.globalCompositeOperation = 'overlay';
          
          // Solar granulation
          for (let i = 0; i < 5000; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 5 + Math.random() * 20;
            const gradient = context.createRadialGradient(x, y, 0, x, y, radius);
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
          }
          
          // Solar flares
          for (let i = 0; i < 5; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 100 + Math.random() * 200;
            const gradient = context.createRadialGradient(x, y, 0, x, y, radius);
            
            gradient.addColorStop(0, 'rgba(255, 255, 100, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
          }
        }
        
        // Create texture from canvas
        const celestialTexture = new THREE.CanvasTexture(celestialCanvas);
        
        const mainCelestialMaterial = new THREE.MeshBasicMaterial({
          map: celestialTexture,
          transparent: true,
          opacity: 0.95
        });
        
        const mainCelestial = new THREE.Mesh(mainCelestialGeometry, mainCelestialMaterial);
        mainCelestial.position.set(30, 20, -30);
        mainCelestial.userData = {
          type: 'celestial',
          radius: 40,
          speed: 0.05,
          originalY: 20
        };
        
        scene.add(mainCelestial);
        objectsRef.current.push(mainCelestial);
        
        // Add improved glow effect
        const glowGeometry = new THREE.SphereGeometry(mainCelestialSize * 1.5, 32, 32);
        const glowMaterial = new THREE.ShaderMaterial({
          uniforms: {
            viewVector: { value: new THREE.Vector3(0, 0, 1) },
            glowColor: { value: new THREE.Color(mainColor) },
            time: { value: 0 }
          },
          vertexShader: `
            uniform vec3 viewVector;
            uniform float time;
            varying float intensity;
            void main() {
              vec3 vNormal = normalize(normalMatrix * normal);
              vec3 vNormel = normalize(normalMatrix * viewVector);
              intensity = pow(1.0 - dot(vNormal, vNormel), 2.0);
              
              // Add subtle pulsation to the glow
              intensity *= 0.8 + 0.2 * sin(time * 0.5);
              
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 glowColor;
            varying float intensity;
            void main() {
              vec3 finalColor = glowColor * intensity;
              gl_FragColor = vec4(finalColor, min(intensity, 1.0));
            }
          `,
          side: THREE.BackSide,
          blending: THREE.AdditiveBlending,
          transparent: true
        });
        
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        mainCelestial.add(glowMesh);
        
        // Add some smaller planets/moons
        const planetCount = Math.floor(Math.random() * 3) + 1;
        
        for (let i = 0; i < planetCount; i++) {
          const planetSize = 1 + Math.random() * 2;
          const planetGeometry = new THREE.SphereGeometry(planetSize, 32, 32);
          
          // Create unique texture for each planet
          const planetCanvas = document.createElement('canvas');
          planetCanvas.width = 512;
          planetCanvas.height = 512;
          const planetContext = planetCanvas.getContext('2d');
          
          // Base color
          const planetColorIndex = Math.floor(Math.random() * settings.colors.length);
          const planetBaseColor = new THREE.Color(settings.colors[planetColorIndex]);
          planetContext.fillStyle = `#${planetBaseColor.getHexString()}`;
          planetContext.fillRect(0, 0, 512, 512);
          
          // Add texture details
          planetContext.globalCompositeOperation = 'overlay';
          
          // Create bands or spots
          if (Math.random() > 0.5) {
            // Banded planet (like Jupiter)
            for (let band = 0; band < 10; band++) {
              const y = band * 512 / 10;
              const height = 512 / 10;
              const darkness = Math.random() * 0.4 - 0.2;
              
              planetContext.fillStyle = darkness > 0 ? 
                `rgba(255, 255, 255, ${darkness})` : 
                `rgba(0, 0, 0, ${-darkness})`;
              
              planetContext.fillRect(0, y, 512, height);
            }
          } else {
            // Spotted planet (like Mars)
            for (let spot = 0; spot < 30; spot++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const radius = 5 + Math.random() * 30;
              const darkness = Math.random() * 0.3 - 0.15;
              
              planetContext.fillStyle = darkness > 0 ? 
                `rgba(255, 255, 255, ${darkness})` : 
                `rgba(0, 0, 0, ${-darkness})`;
              
              planetContext.beginPath();
              planetContext.arc(x, y, radius, 0, Math.PI * 2);
              planetContext.fill();
            }
          }
          
          // Create planet texture
          const planetTexture = new THREE.CanvasTexture(planetCanvas);
          
          const planetMaterial = new THREE.MeshStandardMaterial({
            map: planetTexture,
            roughness: 0.8,
            metalness: 0.1
          });
          
          const planet = new THREE.Mesh(planetGeometry, planetMaterial);
          
          const radius = 20 + Math.random() * 30;
          const speed = 0.05 + Math.random() * 0.15;
          const startAngle = Math.random() * Math.PI * 2;
          const inclination = Math.random() * Math.PI * 0.3;
          
          planet.position.set(
            Math.cos(startAngle) * radius,
            10 + Math.random() * 15,
            Math.sin(startAngle) * radius
          );
          
          planet.userData = {
            type: 'celestial',
            radius: radius,
            speed: speed,
            inclination: inclination,
            originalY: planet.position.y
          };
          
          // Add simple atmosphere for some planets
          if (Math.random() > 0.5) {
            const atmoGeometry = new THREE.SphereGeometry(planetSize * 1.1, 32, 32);
            const atmoMaterial = new THREE.MeshBasicMaterial({
              color: planetBaseColor,
              transparent: true,
              opacity: 0.2,
              side: THREE.BackSide
            });
            
            const atmosphere = new THREE.Mesh(atmoGeometry, atmoMaterial);
            planet.add(atmosphere);
          }
          
          scene.add(planet);
          objectsRef.current.push(planet);
        }
      };
      
      // Create improved plants
      const createPlants = (scene, settings) => {
        const plantCount = Math.floor(15 + settings.complexity * 50);
        
        for (let i = 0; i < plantCount; i++) {
          // Create plant with random properties
          const height = 0.5 + Math.random() * 3;
          
          // Create a group for the whole plant
          const plantGroup = new THREE.Group();
          
          // Plant type
          const plantType = Math.random() > 0.3 ? 'flower' : 
                           (Math.random() > 0.5 ? 'grass' : 'tree');
          
          if (plantType === 'flower') {
            // Create stem
            const stemGeometry = new THREE.CylinderGeometry(0.03, 0.06, height, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({
              color: new THREE.Color(0x2e8b57),
              roughness: 0.8,
              metalness: 0.1
            });
            
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = height / 2;
            stem.castShadow = true;
            
            plantGroup.add(stem);
            
            // Create flower
            const petalCount = Math.floor(5 + Math.random() * 7);
            const petalSize = 0.2 + Math.random() * 0.4;
            const flowerColor = new THREE.Color(
              settings.colors[Math.floor(Math.random() * settings.colors.length)]
            );
            
            const flowerGroup = new THREE.Group();
            
            // Different flower types
            const flowerType = Math.random() > 0.5 ? 'daisy' : 'tulip';
            
            if (flowerType === 'daisy') {
              // Daisy-like flower with flat petals
              for (let p = 0; p < petalCount; p++) {
                const angle = (p / petalCount) * Math.PI * 2;
                
                const petalGeometry = new THREE.PlaneGeometry(petalSize * 1.5, petalSize * 0.5);
                const petalMaterial = new THREE.MeshStandardMaterial({
                  color: flowerColor,
                  side: THREE.DoubleSide,
                  roughness: 0.7,
                  metalness: 0
                });
                
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.y = height;
                
                petal.rotation.x = Math.PI / 2;
                petal.rotation.y = angle;
                
                flowerGroup.add(petal);
              }
              
              // Add center of flower
              const centerGeometry = new THREE.SphereGeometry(petalSize * 0.3, 16, 16);
              const centerMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(
                  settings.colors[Math.floor(Math.random() * settings.colors.length)]
                ),
                roughness: 0.6,
                metalness: 0.1
              });
              
              const center = new THREE.Mesh(centerGeometry, centerMaterial);
              center.position.y = height;
              
              flowerGroup.add(center);
            } else {
              // Tulip-like flower with curved petals
              for (let p = 0; p < 6; p++) {
                const angle = (p / 6) * Math.PI * 2;
                
                // Create curved petal using extruded shape
                const petalShape = new THREE.Shape();
                petalShape.moveTo(0, 0);
                petalShape.quadraticCurveTo(petalSize * 0.5, petalSize * 1.5, 0, petalSize * 2);
                petalShape.quadraticCurveTo(-petalSize * 0.5, petalSize * 1.5, 0, 0);
                
                const extrudeSettings = {
                  steps: 1,
                  depth: 0.05,
                  bevelEnabled: true,
                  bevelThickness: 0.02,
                  bevelSize: 0.02,
                  bevelSegments: 3
                };
                
                const petalGeometry = new THREE.ExtrudeGeometry(petalShape, extrudeSettings);
                const petalMaterial = new THREE.MeshStandardMaterial({
                  color: flowerColor,
                  roughness: 0.7,
                  metalness: 0
                });
                
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.y = height - petalSize;
                
                petal.rotation.x = -Math.PI / 6; // Tilt petals upwards
                petal.rotation.y = angle;
                
                flowerGroup.add(petal);
              }
            }
            
            plantGroup.add(flowerGroup);
          } else if (plantType === 'grass') {
            // Create grass blades
            const bladeCount = Math.floor(3 + Math.random() * 6);
            const bladeHeight = height * 1.2;
            
            for (let b = 0; b < bladeCount; b++) {
              const curvePoints = [];
              const segments = 8;
              
              // Create a curved blade
              for (let s = 0; s <= segments; s++) {
                const t = s / segments;
                const x = 0.1 * Math.sin(t * Math.PI) * (b % 2 ? 1 : -1);
                const y = bladeHeight * t;
                const z = 0;
                
                curvePoints.push(new THREE.Vector3(x, y, z));
              }
              
              const bladeCurve = new THREE.CatmullRomCurve3(curvePoints);
              const bladeGeometry = new THREE.TubeGeometry(bladeCurve, 8, 0.03, 8, false);
              
              const bladeColor = Math.random() > 0.8 ? 
                new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]) : 
                new THREE.Color(0x3a5f0b);
              
              const bladeMaterial = new THREE.MeshStandardMaterial({
                color: bladeColor,
                roughness: 0.8,
                metalness: 0.1
              });
              
              const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
              
              // Position blade with slight variation
              blade.rotation.y = (b / bladeCount) * Math.PI * 2;
              
              blade.castShadow = true;
              plantGroup.add(blade);
            }
          } else {
            // Create small tree
            const trunkHeight = height * 1.5;
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.2, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
              color: 0x8b4513,
              roughness: 0.9,
              metalness: 0
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            
            plantGroup.add(trunk);
            
            // Add foliage
            const foliageType = Math.random() > 0.7 ? 'pine' : 'rounded';
            
            if (foliageType === 'pine') {
              // Pine tree with cone-shaped foliage
              const levels = Math.floor(2 + Math.random() * 3);
              
              for (let l = 0; l < levels; l++) {
                const coneHeight = trunkHeight * 0.5 - l * 0.2;
                const coneRadius = trunkHeight * 0.25 * (1 - l * 0.1);
                
                const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);
                
                const coneColor = Math.random() > 0.2 ? 
                  new THREE.Color(0x2d4c1e) : 
                  new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]);
                
                const coneMaterial = new THREE.MeshStandardMaterial({
                  color: coneColor,
                  roughness: 0.8,
                  metalness: 0.1
                });
                
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = trunkHeight - l * coneHeight * 0.6;
                cone.castShadow = true;
                
                plantGroup.add(cone);
              }
            } else {
              // Tree with rounded foliage
              const foliageSize = trunkHeight * 0.6;
              const foliageGeometry = new THREE.SphereGeometry(foliageSize, 12, 12);
              
              const foliageColor = Math.random() > 0.2 ? 
                new THREE.Color(0x3a5f0b) : 
                new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]);
              
              const foliageMaterial = new THREE.MeshStandardMaterial({
                color: foliageColor,
                roughness: 0.8,
                metalness: 0.1
              });
              
              const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
              foliage.position.y = trunkHeight + foliageSize * 0.3;
              foliage.castShadow = true;
              
              plantGroup.add(foliage);
            }
          }
          
          // Position plant on terrain
          const x = (Math.random() - 0.5) * 80;
          const z = (Math.random() - 0.5) * 80;
          
          // Adjust for water and other placements
          // Avoid placing in the center (water area)
          const distFromCenter = Math.sqrt(x * x + z * z);
          if (distFromCenter < 30) continue;
          
          plantGroup.position.set(x, -6, z);
          
          // Add randomness to plant properties
          plantGroup.userData = {
            type: 'plant',
            offset: Math.random() * Math.PI * 2,
            originalY: plantGroup.position.y
          };
          
          // Add some random rotation
          plantGroup.rotation.y = Math.random() * Math.PI * 2;
          
          scene.add(plantGroup);
          objectsRef.current.push(plantGroup);
        }
      };
      
      // Create particle systems (fireflies, mist, etc.)
      const createParticles = (scene, settings) => {
        // Choose particle type based on mood
        let particleType;
        
        switch (mood) {
          case 'calm':
            particleType = Math.random() > 0.5 ? 'fireflies' : 'mist';
            break;
          case 'soft':
            particleType = Math.random() > 0.7 ? 'petals' : 'fireflies';
            break;
          case 'uplifting':
            particleType = Math.random() > 0.6 ? 'butterflies' : 'petals';
            break;
          case 'warm':
            particleType = Math.random() > 0.5 ? 'embers' : 'fireflies';
            break;
          case 'cosmic':
            particleType = Math.random() > 0.7 ? 'stardust' : 'mist';
            break;
          default:
            particleType = 'fireflies';
        }
        
        // Create the appropriate particle system
        if (particleType === 'fireflies') {
          createFireflies(scene, settings);
        } else if (particleType === 'mist') {
          createMist(scene, settings);
        } else if (particleType === 'petals') {
          createPetals(scene, settings);
        } else if (particleType === 'embers') {
          createEmbers(scene, settings);
        } else if (particleType === 'stardust') {
          createStardust(scene, settings);
        }
      };
      
      // Create fireflies particle system
      const createFireflies = (scene, settings) => {
        const particleCount = Math.floor(settings.particleCount * 0.3);
        const fireflyGeometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          // Position fireflies in a hemisphere above the ground
          const radius = 10 + Math.random() * 50;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI * 0.5;
          
          positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = 1 + Math.abs(radius * Math.cos(phi)); // Keep above ground
          positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
          
          // Random size and animation offset
          scales[i] = 0.3 + Math.random() * 0.7;
          offsets[i] = Math.random() * Math.PI * 2;
        }
        
        fireflyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        fireflyGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        fireflyGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
        
        // Create a custom shader material for the fireflies
        const fireflyMaterial = new THREE.ShaderMaterial({
          uniforms: {
            color: { value: new THREE.Color(settings.colors[Math.floor(Math.random() * settings.colors.length)]) },
            time: { value: 0 },
            pixelRatio: { value: window.devicePixelRatio },
            audioStrength: { value: 0.0 }
          },
          vertexShader: `
            attribute float scale;
            attribute float offset;
            
            uniform float time;
            uniform float audioStrength;
            uniform float pixelRatio;
            
            varying float vIntensity;
            
            void main() {
              // Firefly movement with small circular motion
              vec3 pos = position;
              
              // Add subtle bobbing motion
              float bobRate = 0.5 + offset * 0.5;
              float bobHeight = 0.2 + scale * 0.3;
              pos.y += sin(time * bobRate + offset) * bobHeight;
              
              // Add gentle circular drift
              float driftRadius = 0.5 + scale * 1.0;
              float driftRate = 0.2 + offset * 0.3;
              pos.x += cos(time * driftRate + offset * 10.0) * driftRadius;
              pos.z += sin(time * driftRate + offset * 10.0) * driftRadius;
              
              // Project position to clip space
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mvPosition;
              
              // Size attenuation
              float computedScale = scale * (1.0 + audioStrength * 2.0);
              gl_PointSize = computedScale * 15.0 * pixelRatio / -mvPosition.z;
              
              // Calculate intensity for the pulsating glow
              float pulseRate = 1.0 + offset * 3.0;
              vIntensity = 0.3 + 0.7 * (0.5 + 0.5 * sin(time * pulseRate));
              vIntensity *= 1.0 + audioStrength;
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            
            varying float vIntensity;
            
            void main() {
              // Calculate distance from the center of the point
              vec2 center = gl_PointCoord - vec2(0.5);
              float dist = length(center);
              
              // Discard pixels outside the radius for round points
              if (dist > 0.5) discard;
              
              // Radial gradient for the glow
              float alpha = smoothstep(0.5, 0.0, dist);
              
              // Apply pulsating intensity
              alpha *= vIntensity;
              
              // Final color with glow
              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const fireflyParticles = new THREE.Points(fireflyGeometry, fireflyMaterial);
        fireflyParticles.userData = { type: 'particles' };
        
        scene.add(fireflyParticles);
        objectsRef.current.push(fireflyParticles);
      };
      
      // Create mist/fog particle system
      const createMist = (scene, settings) => {
        const particleCount = Math.floor(settings.particleCount * 0.5);
        const mistGeometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          // Position mist particles in a layer above the ground
          const radius = Math.random() * 60;
          const theta = Math.random() * Math.PI * 2;
          
          positions[i * 3] = radius * Math.cos(theta);
          positions[i * 3 + 1] = Math.random() * 3; // Low-lying mist
          positions[i * 3 + 2] = radius * Math.sin(theta);
          
          // Random size and animation offset
          scales[i] = 5 + Math.random() * 10;
          offsets[i] = Math.random() * Math.PI * 2;
        }
        
        mistGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        mistGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        mistGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
        
        // Create a texture for mist particles
        const mistCanvas = document.createElement('canvas');
        mistCanvas.width = 128;
        mistCanvas.height = 128;
        const context = mistCanvas.getContext('2d');
        
        // Draw a soft, circular gradient
        const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        context.fillStyle = gradient;
        context.fillRect(0, 0, 128, 128);
        
        const mistTexture = new THREE.CanvasTexture(mistCanvas);
        
        const mistMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: mistTexture },
            color: { value: new THREE.Color(settings.colors[4]) },
            time: { value: 0 },
            audioStrength: { value: 0.0 }
          },
          vertexShader: `
            attribute float scale;
            attribute float offset;
            
            uniform float time;
            uniform float audioStrength;
            
            varying float vScale;
            varying float vOffset;
            
            void main() {
              // Slow drifting motion
              vec3 pos = position;
              
              float driftSpeed = 0.05 + offset * 0.02;
              pos.x += sin(time * driftSpeed + offset * 10.0) * 1.0;
              pos.z += cos(time * driftSpeed + offset * 8.0) * 1.0;
              
              // Gentle bobbing
              pos.y += sin(time * 0.1 + offset) * 0.2;
              
              // Project position to clip space
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mvPosition;
              
              // Pass values to fragment shader
              vScale = scale * (1.0 + audioStrength * 0.5);
              vOffset = offset;
              
              // Size the particles
              gl_PointSize = vScale;
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            uniform vec3 color;
            uniform float time;
            
            varying float vScale;
            varying float vOffset;
            
            void main() {
              // Sample the texture
              vec4 texColor = texture2D(map, gl_PointCoord);
              
              // Slow pulsating opacity
              float opacity = 0.2 + 0.1 * sin(time * 0.2 + vOffset);
              
              // Combine with texture alpha
              gl_FragColor = vec4(color, texColor.a * opacity);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const mistParticles = new THREE.Points(mistGeometry, mistMaterial);
        mistParticles.userData = { type: 'particles' };
        
        scene.add(mistParticles);
        objectsRef.current.push(mistParticles);
      };
      
      // Create falling petals particles
      const createPetals = (scene, settings) => {
        const particleCount = Math.floor(settings.particleCount * 0.3);
        const petalGeometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const rotations = new Float32Array(particleCount);
        const scales = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          // Position petals in a volume above the ground
          const radius = Math.random() * 60;
          const theta = Math.random() * Math.PI * 2;
          
          positions[i * 3] = radius * Math.cos(theta);
          positions[i * 3 + 1] = 5 + Math.random() * 20; // Start high up
          positions[i * 3 + 2] = radius * Math.sin(theta);
          
          // Random rotation, size and animation offset
          rotations[i] = Math.random() * Math.PI * 2;
          scales[i] = 0.5 + Math.random() * 1.0;
          offsets[i] = Math.random() * Math.PI * 2;
        }
        
        petalGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        petalGeometry.setAttribute('rotation', new THREE.BufferAttribute(rotations, 1));
        petalGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        petalGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
        
        // Create a petal texture
        const petalCanvas = document.createElement('canvas');
        petalCanvas.width = 64;
        petalCanvas.height = 64;
        const context = petalCanvas.getContext('2d');
        
        // Draw a petal shape
        context.fillStyle = `#${new THREE.Color(settings.colors[1]).getHexString()}`;
        context.beginPath();
        context.ellipse(32, 32, 16, 24, 0, 0, Math.PI * 2);
        context.fill();
        
        const petalTexture = new THREE.CanvasTexture(petalCanvas);
        
        const petalMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: petalTexture },
            time: { value: 0 },
            audioStrength: { value: 0.0 }
          },
          vertexShader: `
            attribute float rotation;
            attribute float scale;
            attribute float offset;
            
            uniform float time;
            uniform float audioStrength;
            
            varying vec2 vUv;
            varying float vRotation;
            
            void main() {
              // Falling motion with swaying
              vec3 pos = position;
              
              // Falling speed based on scale (larger petals fall faster)
              float fallSpeed = 0.5 + scale * 0.5;
              pos.y -= mod(time * fallSpeed + offset * 10.0, 30.0);
              
              // Swaying motion
              float swayAmount = 2.0 + scale * 2.0;
              pos.x += sin(time * 0.5 + offset * 5.0) * swayAmount;
              pos.z += cos(time * 0.3 + offset * 3.0) * swayAmount;
              
              // Project position to clip space
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mvPosition;
              
              // Vary size with audio reactivity
              float finalScale = scale * (1.0 + audioStrength);
              gl_PointSize = finalScale * 30.0;
              
              // Pass rotation to fragment shader
              vRotation = rotation + time * 0.2 + offset;
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            
            varying float vRotation;
            
            void main() {
              // Apply rotation to UV coordinates
              vec2 uv = gl_PointCoord - 0.5;
              float s = sin(vRotation);
              float c = cos(vRotation);
              vec2 rotatedUv = vec2(
                uv.x * c - uv.y * s,
                uv.x * s + uv.y * c
              ) + 0.5;
              
              // Discard pixels outside the bounds
              if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 || 
                  rotatedUv.y < 0.0 || rotatedUv.y > 1.0) {
                discard;
              }
              
              // Sample the texture
              vec4 texColor = texture2D(map, rotatedUv);
              
              gl_FragColor = texColor;
            }
          `,
          transparent: true,
          depthWrite: false
        });
        
        const petalParticles = new THREE.Points(petalGeometry, petalMaterial);
        petalParticles.userData = { type: 'particles' };
        
        scene.add(petalParticles);
        objectsRef.current.push(petalParticles);
      };
      
      // Create embers/sparks particles
      const createEmbers = (scene, settings) => {
        const particleCount = Math.floor(settings.particleCount * 0.2);
        const emberGeometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        const speeds = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          // Position embers primarily near the ground
          const radius = 20 + Math.random() * 40;
          const theta = Math.random() * Math.PI * 2;
          
          positions[i * 3] = radius * Math.cos(theta);
          positions[i * 3 + 1] = Math.random() * 5; // Start near ground
          positions[i * 3 + 2] = radius * Math.sin(theta);
          
          // Random size, animation offset, and rise speed
          scales[i] = 0.2 + Math.random() * 0.8;
          offsets[i] = Math.random() * Math.PI * 2;
          speeds[i] = 0.5 + Math.random() * 1.5;
        }
        
        emberGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        emberGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        emberGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
        emberGeometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
        
        // Create ember shader material
        const emberMaterial = new THREE.ShaderMaterial({
          uniforms: {
            color1: { value: new THREE.Color(settings.colors[0]) },
            color2: { value: new THREE.Color(settings.colors[1]) },
            time: { value: 0 },
            audioStrength: { value: 0.0 }
          },
          vertexShader: `
            attribute float scale;
            attribute float offset;
            attribute float speed;
            
            uniform float time;
            uniform float audioStrength;
            
            varying float vIntensity;
            varying float vAge;
            
            void main() {
              // Rising motion with some swaying
              vec3 pos = position;
              
              // Lifecycle based on time and offset
              float lifecycle = 10.0; // seconds
              float age = mod(time + offset * lifecycle, lifecycle);
              float normalizedAge = age / lifecycle;
              vAge = normalizedAge;
              
              // Rising with acceleration
              float riseHeight = 15.0 * speed;
              pos.y += normalizedAge * riseHeight;
              
              // Add some swaying
              float swayAmount = 1.0 + scale * 2.0;
              pos.x += sin(age * 2.0 + offset * 10.0) * swayAmount * normalizedAge;
              pos.z += cos(age * 1.5 + offset * 8.0) * swayAmount * normalizedAge;
              
              // Project position to clip space
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mvPosition;
              
              // Size based on lifecycle (grow then shrink)
              float sizeMultiplier = sin(normalizedAge * 3.14159); // peak at middle
              gl_PointSize = scale * 10.0 * sizeMultiplier * (1.0 + audioStrength * 2.0);
              
              // Intensity for the glow effect
              vIntensity = sizeMultiplier * (1.0 + audioStrength);
            }
          `,
          fragmentShader: `
            uniform vec3 color1;
            uniform vec3 color2;
            
            varying float vIntensity;
            varying float vAge;
            
            void main() {
              // Calculate distance from the center of the point
              vec2 center = gl_PointCoord - vec2(0.5);
              float dist = length(center);
              
              // Discard pixels outside the radius for round points
              if (dist > 0.5) discard;
              
              // Radial gradient for the glow
              float alpha = smoothstep(0.5, 0.0, dist) * vIntensity;
              
              // Color transition based on age
              vec3 finalColor = mix(color1, color2, vAge);
              
              // Apply glow intensity
              gl_FragColor = vec4(finalColor, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const emberParticles = new THREE.Points(emberGeometry, emberMaterial);
        emberParticles.userData = { type: 'particles' };
        
        scene.add(emberParticles);
        objectsRef.current.push(emberParticles);
      };
      
      // Create cosmic stardust particles
      const createStardust = (scene, settings) => {
        const particleCount = Math.floor(settings.particleCount * 0.5);
        const stardustGeometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const offsets = new Float32Array(particleCount);
        
        // Color palette from settings
        const palette = settings.colors.map(c => new THREE.Color(c));
        
        for (let i = 0; i < particleCount; i++) {
          // Position stardust in 3D space
          const radius = 10 + Math.random() * 70;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI - Math.PI / 2; // -90 to +90 degrees
          
          positions[i * 3] = radius * Math.cos(phi) * Math.cos(theta);
          positions[i * 3 + 1] = 5 + radius * Math.sin(phi); // Keep most particles above ground
          positions[i * 3 + 2] = radius * Math.cos(phi) * Math.sin(theta);
          
          // Assign color from palette
          const color = palette[Math.floor(Math.random() * palette.length)];
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
          
          // Random size and animation offset
          scales[i] = 0.3 + Math.random() * 1.7;
          offsets[i] = Math.random() * Math.PI * 2;
        }
        
        stardustGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        stardustGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        stardustGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        stardustGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
        
        // Create stardust shader material
        const stardustMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            audioStrength: { value: 0.0 }
          },
          vertexShader: `
            attribute vec3 color;
            attribute float scale;
            attribute float offset;
            
            uniform float time;
            uniform float audioStrength;
            
            varying vec3 vColor;
            varying float vIntensity;
            
            void main() {
              // Flowing motion in 3D space
              vec3 pos = position;
              
              // Complex orbital-like motion
              float timeScale = 0.2;
              float radiusX = length(pos.yz);
              float radiusY = length(pos.xz);
              float radiusZ = length(pos.xy);
              
              float angleX = atan(pos.z, pos.y) + time * timeScale * 0.2 + offset;
              float angleY = atan(pos.z, pos.x) + time * timeScale * 0.3 + offset * 2.0;
              float angleZ = atan(pos.y, pos.x) + time * timeScale * 0.1 - offset;
              
              pos.y = radiusX * cos(angleX);
              pos.z = radiusX * sin(angleX);
              
              pos.x = radiusY * cos(angleY);
              pos.z = mix(pos.z, radiusY * sin(angleY), 0.5);
              
              pos.x = mix(pos.x, radiusZ * cos(angleZ), 0.2);
              pos.y = mix(pos.y, radiusZ * sin(angleZ), 0.2);
              
              // Project position to clip space
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_Position = projectionMatrix * mvPosition;
              
              // Size with distance attenuation and audio reactivity
              float computedScale = scale * (1.0 + audioStrength * 3.0);
              gl_PointSize = computedScale * 8.0 / -mvPosition.z;
              
              // Pass color to fragment shader
              vColor = color;
              
              // Calculate intensity for pulsating effect
              float pulse = 0.5 + 0.5 * sin(time + offset * 10.0);
              vIntensity = 0.5 + 0.5 * pulse + audioStrength;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying float vIntensity;
            
            void main() {
              // Calculate distance from the center of the point
              vec2 center = gl_PointCoord - vec2(0.5);
              float dist = length(center);
              
              // Discard pixels outside the radius for round points
              if (dist > 0.5) discard;
              
              // Radial gradient for the glow
              float alpha = smoothstep(0.5, 0.0, dist) * vIntensity;
              
              // Apply glow intensity to color and alpha
              vec3 glowColor = vColor * vIntensity;
              
              gl_FragColor = vec4(glowColor, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        const stardustParticles = new THREE.Points(stardustGeometry, stardustMaterial);
        stardustParticles.userData = { type: 'particles' };
        
        scene.add(stardustParticles);
        objectsRef.current.push(stardustParticles);
      };
      
      // Create volumetric clouds
      const createClouds = (scene, settings) => {
        // Skip clouds for cosmic mood
        if (mood === 'cosmic') return;
        
        const cloudCount = Math.floor(5 + settings.complexity * 10);
        
        for (let i = 0; i < cloudCount; i++) {
          // Create a cloud group
          const cloudGroup = new THREE.Group();
          
          // Cloud position
          const radius = 20 + Math.random() * 50;
          const angle = Math.random() * Math.PI * 2;
          
          cloudGroup.position.set(
            radius * Math.cos(angle),
            15 + Math.random() * 20,
            radius * Math.sin(angle)
          );
          
          // Create multiple billowy shapes
          const particleCount = Math.floor(3 + Math.random() * 8);
          
          for (let p = 0; p < particleCount; p++) {
            const size = 2 + Math.random() * 4;
            
            const cloudGeometry = new THREE.SphereGeometry(size, 8, 8);
            
            // Get color based on mood, but make it light and airy
            const baseColor = new THREE.Color(settings.colors[4]); // Lightest color
            const cloudColor = new THREE.Color().set(baseColor).lerp(new THREE.Color(0xffffff), 0.7);
            
            const cloudMaterial = new THREE.MeshStandardMaterial({
              color: cloudColor,
              transparent: true,
              opacity: 0.4 + Math.random() * 0.3,
              roughness: 1.0,
              metalness: 0
            });
            
            const cloudPuff = new THREE.Mesh(cloudGeometry, cloudMaterial);
            
            // Position within the cloud group
            cloudPuff.position.set(
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 5
            );
            
            cloudGroup.add(cloudPuff);
          }
          
          cloudGroup.userData = {
            type: 'cloud',
            offset: Math.random() * Math.PI * 2,
            baseOpacity: 0.4 + Math.random() * 0.3
          };
          
          scene.add(cloudGroup);
          objectsRef.current.push(cloudGroup);
        }
      };
      
      return <canvas ref={canvasRef} className="visual-canvas" />;
    });

    // Onboarding Component
    const Onboarding = ({ moodDescriptions, onEnter }) => {
      return (
        <div className="onboarding-overlay">
          <div className="onboarding-container">
            <div className="onboarding-card">
              <h1 className="onboarding-logo">Harmonic Visions</h1>
              <div className="onboarding-subheading">An immersive audiovisual journey</div>
              
              <p className="onboarding-description">
                Experience a mesmerizing fusion of evolving landscapes, harmonious sounds, and responsive visuals 
                designed to create a deeply immersive and transcendent experience. Each mood offers a unique 
                journey that resonates with different emotional states.
              </p>
              
              <div className="creator-attribution">
                FatStinkyPanda's Transcendence Experience - Unlock your mind and connect with the universe
              </div>
              
              <div className="experience-cards">
                {Object.entries(moodDescriptions).map(([mood, description]) => (
                  <div className="experience-card" key={mood}>
                    <h3>{mood.charAt(0).toUpperCase() + mood.slice(1)}</h3>
                    <p>{description}</p>
                  </div>
                ))}
              </div>
              
              <div className="support-message">
                <p>If you enjoy this experience and find it valuable, your support helps me continue creating more immersive journeys. Thanks for being part of this adventure!</p>
              </div>
              
              <button className="enter-button" onClick={onEnter}>
                Begin Journey
              </button>
            </div>
          </div>
        </div>
      );
    };

    // LoadingIndicator Component
    const LoadingIndicator = () => {
      return (
        <div className="loading-indicator">
          <div className="spinner"></div>
          <div className="loading-text">Creating your experience...</div>
        </div>
      );
    };

    // Main App Component
    function App() {
      // State variables for the application
      const [isPlaying, setIsPlaying] = React.useState(false);
      const [volume, setVolume] = React.useState(0.7);
      const [currentMood, setCurrentMood] = React.useState('calm');
      const [showExportPanel, setShowExportPanel] = React.useState(false);
      const [isExporting, setIsExporting] = React.useState(false);
      const [exportProgress, setExportProgress] = React.useState(0);
      const [exportDuration, setExportDuration] = React.useState(30);
      const [exportQuality, setExportQuality] = React.useState('high');
      const [exportFormat, setExportFormat] = React.useState('webm');
      const [showOnboarding, setShowOnboarding] = React.useState(true);
      const [isLoading, setIsLoading] = React.useState(false);
      
      // References
      const canvasRef = React.useRef(null);
      const audioEngineRef = React.useRef(null);
      const videoExporterRef = React.useRef(null);
      const exportTimerRef = React.useRef(null);
      
      // Get audio data for visualization
      const getAudioData = () => {
        if (audioEngineRef.current && typeof audioEngineRef.current.getAudioData === 'function') {
          return audioEngineRef.current.getAudioData();
        }
        return null;
      };
      
      // Initialize video exporter
      React.useEffect(() => {
        if (canvasRef.current && audioEngineRef.current) {
          try {
            videoExporterRef.current = new VideoExporter(
              canvasRef.current.canvas,
              audioEngineRef.current.audioContext,
              audioEngineRef.current.analyser
            );
          } catch (error) {
            console.error("Failed to initialize video exporter:", error);
            ToastSystem.notify('error', 'Could not initialize video export. Some features may be unavailable.');
          }
        }
      }, []);
      
      // Set up keyboard shortcuts
      React.useEffect(() => {
        const handleKeyPress = (e) => {
          // Space bar to toggle play/pause
          if (e.code === 'Space' && !showOnboarding) {
            e.preventDefault(); // Prevent scrolling
            togglePlayback();
          }
          
          // 1-5 to change moods
          if (e.code === 'Digit1' || e.code === 'Numpad1') setCurrentMood('calm');
          if (e.code === 'Digit2' || e.code === 'Numpad2') setCurrentMood('soft');
          if (e.code === 'Digit3' || e.code === 'Numpad3') setCurrentMood('uplifting');
          if (e.code === 'Digit4' || e.code === 'Numpad4') setCurrentMood('warm');
          if (e.code === 'Digit5' || e.code === 'Numpad5') setCurrentMood('cosmic');
          
          // E to toggle export panel
          if (e.code === 'KeyE') {
            setShowExportPanel(prev => !prev);
          }
        };
        
        window.addEventListener('keydown', handleKeyPress);
        
        return () => {
          window.removeEventListener('keydown', handleKeyPress);
        };
      }, [showOnboarding]);
      
      // Handle enter from onboarding
      const handleEnterExperience = () => {
        setIsLoading(true);
        
        // Allow a brief moment for loading screen to display
        setTimeout(() => {
          setShowOnboarding(false);
          setIsLoading(false);
          
          // Auto-play when entering the experience
          setIsPlaying(true);
        }, 1500);
      };
      
      // Handle play/pause
      const togglePlayback = () => {
        setIsPlaying(!isPlaying);
      };
      
      // Handle volume change
      const handleVolumeChange = (newVolume) => {
        setVolume(newVolume);
      };
      
      // Handle mood change
      const handleMoodChange = (mood) => {
        setCurrentMood(mood);
        ToastSystem.notify('info', `Mood changed to ${mood.charAt(0).toUpperCase() + mood.slice(1)}`);
      };
      
      // Show/hide export panel
      const toggleExportPanel = () => {
        setShowExportPanel(!showExportPanel);
      };
      
      // Handle export quality change
      const handleExportQualityChange = (quality) => {
        setExportQuality(quality);
      };
      
      // Handle export format change
      const handleExportFormatChange = (format) => {
        setExportFormat(format);
      };
      
      // Handle export duration change
      const handleExportDurationChange = (duration) => {
        setExportDuration(duration);
      };
      
      // Start export process
      const startExport = async () => {
        if (!videoExporterRef.current) {
          ToastSystem.notify('error', 'Video export is not available. Refresh the page and try again.');
          return;
        }
        
        try {
          // Start recording
          setIsExporting(true);
          setExportProgress(0);
          
          // Ensure audio is playing
          if (!isPlaying) {
            setIsPlaying(true);
          }
          
          ToastSystem.notify('info', 'Recording started. Please wait...');
          
          // Start media recorder
          const mediaRecorder = await videoExporterRef.current.startRecording(exportQuality);
          
          // Set up progress updates
          const updateInterval = 100; // Update every 100ms
          const totalUpdates = exportDuration * (1000 / updateInterval);
          let updateCount = 0;
          
          exportTimerRef.current = setInterval(() => {
            updateCount++;
            const progress = (updateCount / totalUpdates) * 100;
            setExportProgress(Math.min(progress, 99)); // Cap at 99% until finished
            
            if (updateCount >= totalUpdates) {
              clearInterval(exportTimerRef.current);
              finishExport();
            }
          }, updateInterval);
          
        } catch (error) {
          console.error('Error starting export:', error);
          ToastSystem.notify('error', 'Failed to start recording. Please try again.');
          setIsExporting(false);
          clearInterval(exportTimerRef.current);
        }
      };
      
      // Finish export process
      const finishExport = async () => {
        try {
          ToastSystem.notify('info', 'Processing video...');
          
          // Stop recording
          const blob = await videoExporterRef.current.stopRecording();
          
          // Convert if needed
          const finalBlob = await videoExporterRef.current.convertToFormat(
            blob,
            exportFormat,
            (progress) => {
              setExportProgress(99 + progress * 0.01); // Use the last 1% for conversion
            }
          );
          
          // Create download link
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `harmonic-visions-${currentMood}-${timestamp}.${exportFormat === 'mp4' ? 'webm' : exportFormat}`;
          const link = videoExporterRef.current.createDownloadLink(finalBlob, filename);
          
          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Cleanup
          setExportProgress(100);
          
          ToastSystem.notify('success', 'Video created successfully! Download started.');
          
          setTimeout(() => {
            setIsExporting(false);
            setExportProgress(0);
            setShowExportPanel(false);
          }, 1500);
          
        } catch (error) {
          console.error('Error completing export:', error);
          ToastSystem.notify('error', 'Failed to complete recording. Try a shorter duration or refresh the page.');
          setIsExporting(false);
          setExportProgress(0);
        }
      };
      
      // Enhanced Export Panel
      const EnhancedExportPanel = () => {
        // Calculate estimated time based on quality and duration
        const calculateEstimatedTime = () => {
          // Base times in seconds per minute of video
          const baseTimes = {
            low: 5,
            medium: 12,
            high: 20,
            ultra: 40
          };
          
          // Adjust time based on format (WebM is the reference)
          const formatMultiplier = format === 'gif' ? 2.0 : (format === 'mp4' ? 1.2 : 1.0);
          
          // Calculate total estimated seconds
          const estimatedSeconds = (exportDuration / 60) * baseTimes[exportQuality] * formatMultiplier;
          
          // Convert to minutes and seconds
          const minutes = Math.floor(estimatedSeconds / 60);
          const seconds = Math.floor(estimatedSeconds % 60);
          
          return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        };
        
        return (
          <div className="panel active">
            <div className="panel-header">
              <h2>Export Video</h2>
              <button 
                className="close-button"
                onClick={toggleExportPanel}
                disabled={isExporting}
                aria-label="Close export panel"
              >
                ×
              </button>
            </div>
            
            {isExporting ? (
              <div className="progress-container">
                <div className="progress-bar">
                  <div className="progress-fill" style={{ width: `${exportProgress}%` }}></div>
                </div>
                <div className="progress-text">
                  {exportProgress < 99 ? 
                    `Recording: ${exportProgress.toFixed(0)}%` : 
                    'Processing video...'}
                </div>
              </div>
            ) : (
              <>
                <div className="setting-group">
                  <label htmlFor="duration">Duration</label>
                  <input
                    id="duration"
                    type="number"
                    min="5"
                    max="300"
                    value={exportDuration}
                    onChange={(e) => handleExportDurationChange(parseInt(e.target.value))}
                  />
                </div>
                
                <div className="setting-group">
                  <label>Quality</label>
                  <div className="quality-options">
                    {qualityOptions.map(opt => (
                      <div 
                        key={opt.id}
                        className={`quality-option ${exportQuality === opt.id ? 'selected' : ''}`}
                        onClick={() => handleExportQualityChange(opt.id)}
                      >
                        <h4>{opt.label}</h4>
                        <p>{
                          opt.id === 'low' ? 'Faster export' :
                          opt.id === 'ultra' ? 'Best quality' :
                          `Balanced ${opt.id === 'medium' ? 'performance' : 'quality'}`
                        }</p>
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="setting-group">
                  <label>Format</label>
                  <div className="format-options">
                    {formatOptions.map(opt => (
                      <div 
                        key={opt.id}
                        className={`format-option ${exportFormat === opt.id ? 'selected' : ''}`}
                        onClick={() => handleExportFormatChange(opt.id)}
                      >
                        <div className="format-icon">{
                          opt.id === 'webm' ? '🎥' :
                          opt.id === 'mp4' ? '📹' : '🖼️'
                        }</div>
                        <div className="format-label">{opt.label}</div>
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="estimated-time">
                  Estimated Processing Time: {calculateEstimatedTime()}
                </div>
                
                <button 
                  className="action-button"
                  onClick={startExport}
                >
                  Start Recording
                </button>
              </>
            )}
          </div>
        );
      };
      
      return (
        <div className="app-container">
          {showOnboarding ? (
            <Onboarding 
              moodDescriptions={moodDescriptions} 
              onEnter={handleEnterExperience} 
            />
          ) : (
            <>
              <div className="app-header">
                <h1 className="app-title">Harmonic Visions</h1>
                <div className="creator-badge">
                  FatStinkyPanda's Transcendence Experience
                  <span className="support-text">Thanks for your support!</span>
                </div>
              </div>
              
              <div className="main-content">
                <VisualCanvas 
                  ref={canvasRef}
                  isPlaying={isPlaying}
                  mood={currentMood}
                  audioData={getAudioData}
                />
                
                <AudioEngine 
                  ref={audioEngineRef}
                  isPlaying={isPlaying}
                  volume={volume}
                  mood={currentMood}
                />
                
                <div className="control-panel">
                  <div className="control-group">
                    <button 
                      className="play-button" 
                      onClick={togglePlayback}
                      aria-label={isPlaying ? "Pause" : "Play"}
                    >
                      {isPlaying ? '❚❚' : '▶'}
                    </button>
                  </div>
                  
                  <div className="control-group">
                    <label htmlFor="volume">Volume</label>
                    <input 
                      id="volume"
                      type="range" 
                      min="0" 
                      max="1" 
                      step="0.01" 
                      value={volume} 
                      onChange={(e) => handleVolumeChange(parseFloat(e.target.value))} 
                    />
                  </div>
                  
                  <div className="control-group">
                    <label htmlFor="mood">Mood</label>
                    <div className="mood-tooltip">{moodDescriptions[currentMood]}</div>
                    <select 
                      id="mood"
                      className="control-select"
                      value={currentMood} 
                      onChange={(e) => handleMoodChange(e.target.value)}
                    >
                      {moods.map(m => (
                        <option key={m.id} value={m.id}>{m.label}</option>
                      ))}
                    </select>
                  </div>
                  
                  <div className="control-group">
                    <button 
                      className="export-button"
                      onClick={toggleExportPanel}
                      disabled={isExporting}
                    >
                      <span className="export-button-icon">↓</span>
                      Export Video
                    </button>
                  </div>
                </div>
                
                {showExportPanel && <EnhancedExportPanel />}
                
                <div className="keyboard-shortcuts">
                  Shortcuts: <span className="keyboard-shortcut">Space</span> Play/Pause
                  <span className="keyboard-shortcut">1-5</span> Change Mood
                  <span className="keyboard-shortcut">E</span> Export
                </div>
              </div>
            </>
          )}
          
          {isLoading && <LoadingIndicator />}
          
          <ToastContainer />
        </div>
      );
    }

    // Render the app
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
  
  <!-- Buy Me a Coffee widget -->
  <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="FatStinkyPanda" data-description="Support me on Buy me a coffee!" data-message="I hope you enjoyed this!! If it's not too much to ask, your support allows me to provide more awesome goodness! :)" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
</body>
</html>